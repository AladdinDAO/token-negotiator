{"version":3,"sources":["TokenScript/Attestation/SignedDevonTicket.js","TokenScript/Attestation/AlgorithmIdentifier.js","TokenScript/Attestation/PublicKeyInfo.js","TokenScript/Negotiator.js","Card/index.js","App.js","reportWebVitals.js","index.js"],"names":["DevconTicket","source","TypeError","ArrayBuffer","asn1","fromBER","this","fromSchema","result","devconId","getParametersValue","ticketId","ticketClass","schema","clearProps","compareSchema","verified","Error","valueBlock","_valueHex","BigInt","bufferToHexCodes","value","parameters","names","Sequence","name","blockName","Integer","SignedDevconTicket","ticketEncoded","startsWith","URL","searchParams","get","base64str","split","join","Buffer","Uint8Array","from","buffer","atob","c","charCodeAt","ticket","commitment","publicKeyInfo","PublicKeyInfo","signatureValue","valueBeforeDecode","valueHex","OctetString","optional","BitString","AlgorithmIdentifier","algorithmId","algorithmParams","defaultValues","algorithmIdentifier","algorithm","toString","params","outputArray","push","ObjectIdentifier","asn1js","Any","object","toJSON","JSON","stringify","memberName","memberValue","signatureAlgorithm","publicKey","Negotiator","filter","urlParams","URLSearchParams","window","location","search","ticketFromQuery","secretFromQuery","storageTickets","localStorage","getItem","ticketObject","ticketDecodedString","isValidTicket","tickets","raw","web","isNewQueryTicket","length","parse","map","ticketBlob","storedTicketObject","secret","setItem","useStyles","makeStyles","root","maxWidth","media","height","MediaCard","tokenInstance","classes","Card","className","CardMedia","image","title","CardContent","Typography","gutterBottom","variant","component","color","App","useState","tokens","setTokens","negotiator","useEffect","getTokenInstances","then","error","console","log","index","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.59a40319.chunk.js","sourcesContent":["import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER\n} from \"asn1js\";\nimport { getParametersValue, clearProps, bufferToHexCodes } from \"pvutils\";\nimport PublicKeyInfo from \"./PublicKeyInfo.js\";\nimport BigInt from \"big-integer\";\n\nexport class DevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is CER encoded\n   */\n  constructor(source = {}) {\n    if (typeof (source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      this.devconId = getParametersValue(\n        source,\n        \"devconId\"\n      );\n      this.ticketId = getParametersValue(\n        source,\n        \"ticketId\"\n      );\n      this.ticketClass = getParametersValue(\n        source,\n        \"ticketClass\"\n      );\n    }\n  }\n\n  static schema(parameters = {}) {\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"ticket\",\n      value: [\n        new Integer({\n          name: names.devconId || \"devconId\",\n        }),\n        new Integer({\n          name: names.ticketId || \"ticketId\",\n        }),\n        new Integer({\n          name: names.ticketClass || \"ticketClass\",\n        }),\n      ],\n    });\n  }\n\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"devconId\",\n      \"ticketId\",\n      \"ticketClass\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, DevconTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\"Object's schema was not verified against input data for DevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    if (\"devconId\" in asn1.result) {\n      const devconId = asn1.result[\"devconId\"].valueBlock._valueHex;\n      this.devconId = new BigInt(\"0x\" + bufferToHexCodes(devconId)).value;\n    }\n\n    if (\"ticketId\" in asn1.result) {\n      const ticketId = asn1.result[\"ticketId\"].valueBlock._valueHex\n      this.ticketId = new BigInt(\"0x\" + bufferToHexCodes(ticketId)).value;\n    }\n\n    if (\"ticketClass\" in asn1.result) {\n      const ticketClass = asn1.result[\"ticketClass\"].valueBlock._valueHex;\n      this.ticketClass = new BigInt(\"0x\" + bufferToHexCodes(ticketClass)).value;\n    }\n\n    //endregion\n  }\n}\n\nexport class SignedDevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is DER encoded\n   */\n  constructor(source = {}) {\n    if (typeof (source) == \"string\") {\n\n      const ticketEncoded = (source.startsWith(\"https://\")) ?\n        (new URL(source)).searchParams.get('ticket') : source;\n\n      let base64str = ticketEncoded\n        .split('_').join('+')\n        .split('-').join('/')\n        .split('.').join('=');\n\n      // source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      if (typeof Buffer !== 'undefined') {\n        source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      } else {\n        source = Uint8Array.from(atob(base64str), c => c.charCodeAt(0)).buffer;\n      }\n\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source);\n      this.fromSchema(asn1.result);\n    } else {\n      this.ticket = new DevconTicket(source.ticket);\n\n      this.commitment = getParametersValue(\n        source,\n        \"commitment\"\n      );\n\n      // TODO: issue #75\n      // this.signatureAlgorithm = new AlgorithmIdentifier(source.signatureAlgorithm);\n\n      this.publicKeyInfo = new PublicKeyInfo(source.publicKeyInfo)\n\n      this.signatureValue = getParametersValue(\n        source,\n        \"signatureValue\"\n      );\n    }\n  }\n\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * CertificateList  ::=  SEQUENCE  {\n   *    tbsCertList          TBSCertList,\n   *    signatureAlgorithm   AlgorithmIdentifier,\n   *    signatureValue       BIT STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} [blockName]\n     * @property {string} [signatureAlgorithm]\n     * @property {string} [signatureValue]\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"SignedDevconTicket\",\n      value: [\n        DevconTicket.schema(parameters),\n        new OctetString({\n          name: \"commitment\",\n        }),\n        /* PublicKeyInfo is specified in schema here but not appearing in the constructed data object.\n         * This is because the underlying AlgorithmIdentifier isn't fully implemented and also\n         * that this data is not important for the 1st delivery deadline, won't be read by client anyway.\n         * TODO: add support for PublicKeyInfo https://github.com/TokenScript/attestation/issues/75\n         */\n        new Sequence({\n          name: \"publicKeyInfo\",\n          optional: true,\n          value: [\n            PublicKeyInfo.schema(\n              names.publicKeyInfo || {\n                names: {\n                  blockName: \"publicKeyInfo\",\n                },\n              }\n            )\n          ]\n        }),\n\n        new BitString({\n          name: \"signatureValue\",\n        }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"ticket\",\n      \"commitment\",\n      // TODO: #75\n      \"publicKeyInfo\",\n      \"signatureValue\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, SignedDevconTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\"Object's schema was not verified against input data for SignedDevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    this.ticket = new DevconTicket(asn1.result.ticket.valueBeforeDecode)\n\n    if (\"commitment\" in asn1.result)\n      this.commitment = asn1.result[\"commitment\"].valueBlock.valueHex;\n\n    // TODO: issue #75\n    // this.signatureAlgorithm = new AlgorithmIdentifier(asn1.result.signatureAlgorithm);\n    this.publicKeyInfo = new PublicKeyInfo({\n      schema: asn1.result.publicKeyInfo,\n    });\n\n    const signatureValue = asn1.result.signatureValue;\n    this.signatureValue = signatureValue.valueBlock.valueHex;    //endregion\n  }\n}","import { Any, compareSchema, ObjectIdentifier, Sequence } from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class AlgorithmIdentifier {\n  //**********************************************************************************\n  /**\n   * Constructor for AlgorithmIdentifier class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.algorithmId = getParametersValue(\n          source,\n          \"algorithmId\"\n      );\n\n      if (\"algorithmParams\" in source)\n        /**\n         * @type {Object}\n         * @desc Any algorithm source\n         */\n        this.algorithmParams = getParametersValue(\n            source,\n            \"algorithmParams\",\n            AlgorithmIdentifier.defaultValues(\"algorithmParams\")\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n   /* FIXME: algorithmParams is options hence not removed and we need to complete this with all parameters with their default value covered here.\n   */\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithmParams\":\n        return new Any();\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return memberValue === \"\";\n      case \"algorithmParams\":\n        return memberValue instanceof asn1js.Any;\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * AlgorithmIdentifier  ::=  Sequence  {\n   *    algorithm               OBJECT IDENTIFIER,\n   *    parameters              ANY DEFINED BY algorithm OPTIONAL  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\n     * @property {string} algorithmParams Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || false,\n      value: [\n        new ObjectIdentifier({ name: names.algorithmIdentifier || \"algorithm\" }),\n        new Any({ name: names.algorithmParams || \"parameters\", optional: true }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"algorithm\", \"params\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      AlgorithmIdentifier.schema({\n        names: {\n          algorithmIdentifier: \"algorithm\",\n          algorithmParams: \"params\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n\n    //region Get internal properties from parsed schema\n    this.algorithmId = asn1.result.algorithm.valueBlock.toString();\n    if (\"params\" in asn1.result) this.algorithmParams = asn1.result.params;\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    outputArray.push(new ObjectIdentifier({ value: this.algorithmId }));\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      outputArray.push(this.algorithmParams);\n    //endregion\n\n    //region Construct and return new ASN.1 schema for this object\n    return new Sequence({\n      value: outputArray,\n    });\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n  toJSON() {\n    const object = {\n      algorithmId: this.algorithmId,\n    };\n\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      object.algorithmParams = this.algorithmParams.toJSON();\n\n    return object;\n  }\n  //**********************************************************************************\n  /**\n   * Check that two \"AlgorithmIdentifiers\" are equal\n   * @param {AlgorithmIdentifier} algorithmIdentifier\n   * @returns {boolean}\n   */\n  isEqual(algorithmIdentifier) {\n    //region Check input type\n    if (algorithmIdentifier instanceof AlgorithmIdentifier === false)\n      return false;\n    //endregion\n\n    //region Check \"algorithm_id\"\n    if (this.algorithmId !== algorithmIdentifier.algorithmId) return false;\n    //endregion\n\n    //region Check \"algorithm_params\"\n    if (\"algorithmParams\" in this) {\n      if (\"algorithmParams\" in algorithmIdentifier)\n        return (\n          JSON.stringify(this.algorithmParams) ===\n          JSON.stringify(algorithmIdentifier.algorithmParams)\n        );\n\n      return false;\n    }\n\n    if (\"algorithmParams\" in algorithmIdentifier) return false;\n    //endregion\n\n    return true;\n  }\n  //**********************************************************************************\n}\n//**************************************************************************************\n","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER,\n  Any,\n  ObjectIdentifier\n} from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class PublicKeyInfo {\n  //**********************************************************************************\n  /**\n   * Constructor for PublicKeyInfo class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Not accepting string. For base64, convert to ArrayBuffer.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.signatureAlgorithm = getParametersValue(\n          source,\n          \"signatureAlgorithm\"\n      );\n\t  this.publicKey = getParametersValue(\n          source,\n          \"publicKey\"\n      );\n    }\n  }\n \n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * PublicKeyInfo  ::=  Sequence  {\n   *    signatureAlgorithm               AlgorithmIdentifier,\n   *    publicKey              BIT-STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} signatureAlgorithm ObjectIdentifier for the algorithm\n     * @property {string} publicKey Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: true,\n      value: [\n\t\tAlgorithmIdentifier.schema(\n\t\t\tnames.signatureAlgorithm || {\n\t\t\t  names: {\n\t\t\t\tblockName: \"signatureAlgorithm\",\n\t\t\t  },\n\t\t\t}\n\t\t),\n        new BitString({ name: \"publicKey\"}),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"signatureAlgorithm\", \"publicKey\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      PublicKeyInfo.schema({\n        names: {\n          signatureAlgorithm: \"signatureAlgorithm\",\n          publicKey: \"publicKey\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n  }\n}\n//**************************************************************************************\n","// https://github.com/TokenScript/attestation/blob/main/src/main/javascript/SignedDevonTicket.js\nimport { SignedDevconTicket } from './Attestation/SignedDevonTicket';\n\nexport class Negotiator {\n  \n  constructor(filter) {\n    this.filter = filter;\n  }\n\n  // Get the token instances (with filter)\n  async getTokenInstances() {\n    // Get ticket from params - to add to local storage / read into app\n    const urlParams = new URLSearchParams(window.location.search);\n    const ticketFromQuery = urlParams.get('ticket');\n    const secretFromQuery = urlParams.get('secret');\n    // Get the current Storage Tokens (DER format)\n    const storageTickets = localStorage.getItem('dcTokens');\n    // Decode the current ticket (DER format)\n    // root object { commitment, publicKeyInfo, signatureValue, ticket } \n    // ticket example: \"SignedDevconTicket{ticket: DevconTicket {devconId: 6n,ticketId: 417541561855n,ticketClass: 0n},commitment: ArrayBuffer {[Uint8Contents]: <04 12 35 64 9d 5b fd 29 fe c5 d8 5b 6d e9 05 4e dc 8d 36 79 16 9d 88 4d 64 27 a9 2f af dd f8 fd 30 29 38 b6 71 ae 1e 46 2f 78 cb a0 4c fd 26 fe 36 16 ca 4f bf f2 c7 15 ae 8c f4 06 8e b8 b0 2f 22>,byteLength: 65},publicKeyInfo: PublicKeyInfo { signatureAlgorithm: undefined, publicKey: undefined },signatureValue: ArrayBuffer {[Uint8Contents]: <30 44 02 20 70 2c af bd e4 d3 d9 a3 45 b4 d4 70 c1 7f 26 62 b1 9d 8a 68 da f3 a1 6b b1 45 5f e7 86 31 8b 30 02 20 68 e3 f8 79 55 48 34 7e 71 33 c0 af f4 e5 43 77 23 86 dc 1c 54 ab 23 d5 40 eb 83 53 d3 da 0b da>,byteLength: 70}}'\";\n    let ticketDecodedString;\n    let ticketObject = {};\n    if (ticketFromQuery) {\n      ticketDecodedString = new SignedDevconTicket(ticketFromQuery);\n      // Read from Decoded ticket String\n      ticketObject = ticketDecodedString.ticket;\n    }\n    // Check if the ticket is valid (has data)\n    const isValidTicket = (\n      ticketObject.ticketId,\n      ticketObject.ticketClass,\n      ticketObject.devconId\n    );\n    // Tickets for storage (raw) and for web view\n    const tickets = {\n      raw: [],\n      web: []\n    };\n    // If Valid, return web friendly tickets\n    if (isValidTicket) {\n      // Check if its new or an existing ticket id:\n      // If the ticket from the query is new / or to replace an existing ticket\n      let isNewQueryTicket = true;\n      if (storageTickets && storageTickets.length) {\n        // Build new list of tickets from current and query ticket { ticket, secret }\n        JSON.parse(storageTickets).map((ticketBlob) => {\n          // Decoded string to JS Object\n          const storedTicketObject = new SignedDevconTicket(ticketBlob.ticket);\n          // If the same as a previous ticket - replace with the new ticket\n          if (storedTicketObject.ticket.ticketId == ticketObject.ticketId) {\n            // If new push the DER of the ticket into localstorage\n            tickets.raw.push({ ticket: ticketFromQuery, secret: secretFromQuery });\n            // Push a js object\n            tickets.web.push({\n              devconId: ticketObject.devconId,\n              ticketId: ticketObject.ticketId,\n              ticketClass: ticketObject.ticketClass\n            });\n            isNewQueryTicket = false;\n          } else {\n            // Else push the original DER - Check this is correct.\n            tickets.raw.push(ticketBlob); // contains the ticket and secret\n            tickets.web.push({\n              devconId: storedTicketObject.ticket.devconId,\n              ticketId: storedTicketObject.ticket.ticketId,\n              ticketClass: storedTicketObject.ticket.ticketClass\n            });\n          }\n        });\n      }\n      // Add ticket if new\n      if (isNewQueryTicket) {\n        tickets.raw.push({ ticket: ticketFromQuery, secret: secretFromQuery }); // new raw object\n        tickets.web.push({\n          devconId: ticketObject.devconId,\n          ticketId: ticketObject.ticketId,\n          ticketClass: ticketObject.ticketClass\n        });\n      }\n      // Set New tokens list raw only, websters will be decoded each time\n      localStorage.setItem('dcTokens', JSON.stringify(tickets.raw));\n    } else { // no ticket in browser window, search for localstorage items\n      if (storageTickets && storageTickets.length) {\n        JSON.parse(storageTickets).map((ticketBlob) => {\n          // Decoded string to JS Object\n          const storedTicketObject = new SignedDevconTicket(ticketBlob.ticket);\n          // Push the original DER\n          tickets.raw.push(ticketBlob);\n          tickets.web.push({\n            devconId: storedTicketObject.ticket.devconId,\n            ticketId: storedTicketObject.ticket.ticketId,\n            ticketClass: storedTicketObject.ticket.ticketClass\n          });\n        });\n      }\n    }\n\n    // Return tickets for web\n    return tickets.web;\n  }\n}","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Card from '@material-ui/core/Card';\nimport CardContent from '@material-ui/core/CardContent';\nimport CardMedia from '@material-ui/core/CardMedia';\nimport Typography from '@material-ui/core/Typography';\nimport './Card.css';\n\nconst useStyles = makeStyles({\n  root: {\n    maxWidth: 345,\n  },\n  media: {\n    height: 140,\n  },\n});\n\nfunction MediaCard({ tokenInstance }) {\n  const classes = useStyles();\n  return (\n    <Card className=\"card\">\n      <CardMedia\n        className={classes.media}\n        image=\"./mock.png\"\n        title=\"token\"\n      />\n      <CardContent>\n        <Typography gutterBottom variant=\"h5\" component=\"h2\">\n          {tokenInstance.ticketClass.toString()}\n        </Typography>\n        <Typography variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          Ticket Id: {tokenInstance.ticketId.toString()}\n        </Typography>\n        <Typography variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          Devcon Id: {tokenInstance.devconId.toString()}\n        </Typography>\n      </CardContent>\n    </Card>\n  );\n}\n\nexport default MediaCard;\n","import React, { useState, useEffect } from 'react';\nimport { Negotiator } from './TokenScript';\nimport Card from './Card';\nimport './App.css';\n\n// A minimal example to read tokens and render them to a view.\n\nfunction App() {\n  // local State: tokens[], setTokens: Method to update the state of tokens.\n  let [tokens, setTokens] = useState([]);\n  // create instance of Negotiator.\n  const negotiator = new Negotiator();\n  // react effect\n  useEffect(() => {\n    // on success assign tokens to react state\n    negotiator.getTokenInstances().then((tokens) => {\n      // react event to update state of tokens, component re-renders to show the latest tokens.\n      setTokens(tokens);\n    }, (error) => {\n      console.log(error);\n    });\n  }, []);\n  return (\n    <div>\n      {\n        tokens.length > 0 && tokens.map((tokenInstance, index) => {\n          return <Card key={index} tokenInstance={tokenInstance} />\n        })\n      }\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}