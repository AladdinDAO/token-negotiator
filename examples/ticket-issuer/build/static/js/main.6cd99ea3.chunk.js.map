{"version":3,"sources":["temp/Attestation/AlgorithmIdentifier.js","temp/Attestation/PublicKeyInfo.js","temp/negotiator/index.js","temp/Attestation/SignedDevonTicket.js","Card/index.js","App.js","reportWebVitals.js","index.js"],"names":["AlgorithmIdentifier","source","TypeError","ArrayBuffer","asn1","fromBER","this","fromSchema","result","algorithmId","getParametersValue","algorithmParams","defaultValues","schema","clearProps","compareSchema","names","algorithmIdentifier","verified","Error","algorithm","valueBlock","toString","params","outputArray","push","ObjectIdentifier","value","asn1js","Any","Sequence","object","toJSON","JSON","stringify","memberName","memberValue","parameters","name","blockName","optional","PublicKeyInfo","signatureAlgorithm","publicKey","BitString","getTokenConfig","tokenId","XMLconfig","attestationOrigin","tokenOrigin","tokenUrlName","tokenSecretName","unsignedTokenDataName","tokenIdName","tokenParser","SignedDevconTicket","localStorageItemName","localStorageEthKeyItemName","console","log","Negotiator","filter","options","userPermissionRequired","userPermissionStatus","undefined","queuedCommand","tokensOrigin","debug","hideTokensIframe","addTokenIframe","maxUNlength","UNttl","UNsecret","hasOwnProperty","isTokenOriginWebsite","currentURL","URL","window","location","href","tokensOriginURL","origin","readMagicUrl","attachPostMessageListener","event","data","iframeCommand","remove","tokenEvent","Event","document","body","dispatchEvent","parent","listenForParentMessages","bind","referrer","postMessage","iframeData","a","ethereum","request","method","userAddresses","length","message","connectMetamaskAndGetAddress","provider","ethers","providers","Web3Provider","signer","getSigner","signMessage","magicLink","iframe","createElement","src","style","width","height","opacity","appendChild","bool","parentCommand","parentData","command","Authenticator","rawTokenData","getRawToken","base64ticket","token","ticketSecret","secret","authenticator","tokenObj","ticketBlob","id","email","magic_link","getAuthenticationBlob","res","useToken","success","returnTokensToParent","tokensOutput","readTokens","noTokens","decodedTokens","decodeTokens","tokens","filteredTokens","filterTokens","urlParams","URLSearchParams","search","tokenFromQuery","get","secretFromQuery","idFromQuery","isNewQueryTicket","map","tokenData","localStorage","setItem","Object","keys","filterKeys","forEach","fitFilter","key","o1","o2","p","storageTickets","getItem","output","parse","item","e","callBack","unsignedToken","rawTokens","decodedToken","base64ToUint8array","buffer","decodedTokenData","compareObjects","tokenIframeWrap","display","detachPostMessageListener","listenForIframeMessages","negotiateCallback","signCallback","unEndPoint","Promise","resolve","reject","_authenticate","proof","error","useEthKey","status","getChallengeSigned","createIframe","x","bytes","i","endPoint","expiry","Date","now","random","Math","floor","UN","createHmac","Expiry","randomAndExpiryAsBytes","getInt64Bytes","concat","utils","computeHmac","ethKey","parseInt","substr","storageEthKeys","ethKeys","address","toLowerCase","ethKeyIsValid","signNewChallenge","getUnpredictableNumber","domain","hostname","challenge","signMessageWithBrowserWallet","signature","msgHash","hashMessage","msgHashBytes","arrayify","recoveredAddress","recoverAddress","_negotiate","maxWidth","background","iframeWrap","setAttribute","base64str","split","join","Buffer","Uint8Array","from","atob","c","charCodeAt","listener","addEventListener","attachEvent","removeEventListener","detachEvent","DevconTicket","devconId","ticketId","ticketClass","_valueHex","BigInt","bufferToHexCodes","Utf8String","Integer","ticketEncoded","startsWith","searchParams","ticket","commitment","publicKeyInfo","signatureValue","valueBeforeDecode","valueHex","OctetString","MediaCard","tokenInstance","className","Typography","variant","component","color","mockTicketData","App","hasStorageAccess","then","hasAccess","requestStorageAccess","hasAccessFromRequest","useState","setTokens","negotiator","useEffect","negotiate","devconData","openTicketInNewTab","preventDefault","addTokenThroughIframe","index","mockTicket","onClick","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"0KAMqBA,E,WAQnB,aAA0B,IAAdC,EAAa,uDAAJ,GACnB,GADuB,oBACD,iBAAXA,EACT,MAAM,IAAIC,UAAU,4CAEtB,GAAID,aAAkBE,YAAa,CACjC,IAAMC,EAAOC,QAAQJ,GACrBK,KAAKC,WAAWH,EAAKI,aAMrBF,KAAKG,YAAcC,YACfT,EACA,eAGA,oBAAqBA,IAKvBK,KAAKK,gBAAkBD,YACnBT,EACA,kBACAD,EAAoBY,cAAc,qB,8CA2E5C,SAAWC,GAETC,YAAWD,EAAQ,CAAC,YAAa,WAIjC,IAAMT,EAAOW,YACXF,EACAA,EACAb,EAAoBa,OAAO,CACzBG,MAAO,CACLC,oBAAqB,YACrBN,gBAAiB,aAKvB,IAAsB,IAAlBP,EAAKc,SACP,MAAM,IAAIC,MACR,+EAKJb,KAAKG,YAAcL,EAAKI,OAAOY,UAAUC,WAAWC,WAChD,WAAYlB,EAAKI,SAAQF,KAAKK,gBAAkBP,EAAKI,OAAOe,U,sBAQlE,WAEE,IAAMC,EAAc,GAWpB,OATAA,EAAYC,KAAK,IAAIC,IAAiB,CAAEC,MAAOrB,KAAKG,eAElD,oBAAqBH,MACrBA,KAAKK,2BAA2BiB,OAAOC,OAAQ,GAE/CL,EAAYC,KAAKnB,KAAKK,iBAIjB,IAAImB,IAAS,CAClBH,MAAOH,M,oBASX,WACE,IAAMO,EAAS,CACbtB,YAAaH,KAAKG,aASpB,MALE,oBAAqBH,MACrBA,KAAKK,2BAA2BiB,OAAOC,OAAQ,IAE/CE,EAAOpB,gBAAkBL,KAAKK,gBAAgBqB,UAEzCD,I,qBAQT,SAAQd,GAEN,OAAIA,aAA+BjB,KAAwB,IAKvDM,KAAKG,cAAgBQ,EAAoBR,cAIzC,oBAAqBH,KACnB,oBAAqBW,GAErBgB,KAAKC,UAAU5B,KAAKK,mBACpBsB,KAAKC,UAAUjB,EAAoBN,mBAMrC,oBAAqBM,Q,4BAhK3B,SAAqBkB,GACnB,OAAQA,GACN,IAAK,kBACH,OAAO,IAAIN,IACb,QACE,MAAM,IAAIV,MAAJ,6DACkDgB,O,gCAU9D,SAA0BA,EAAYC,GACpC,OAAQD,GACN,IAAK,cACH,MAAuB,KAAhBC,EACT,IAAK,kBACH,OAAOA,aAAuBR,OAAOC,IACvC,QACE,MAAM,IAAIV,MAAJ,6DACkDgB,O,oBAkB9D,WAAgC,IAAlBE,EAAiB,uDAAJ,GAMnBrB,EAAQN,YAAmB2B,EAAY,QAAS,IAEtD,OAAO,IAAIP,IAAS,CAClBQ,KAAMtB,EAAMuB,WAAa,GACzBC,SAAUxB,EAAMwB,WAAY,EAC5Bb,MAAO,CACL,IAAID,IAAiB,CAAEY,KAAMtB,EAAMC,qBAAuB,cAC1D,IAAIY,IAAI,CAAES,KAAMtB,EAAML,iBAAmB,aAAc6B,UAAU,W,iHCzFpDC,E,WAQnB,aAA0B,IAAdxC,EAAa,uDAAJ,GACnB,GADuB,oBACD,iBAAXA,EACT,MAAM,IAAIC,UAAU,6DAEtB,GAAID,aAAkBE,YAAa,CACjC,IAAMC,EAAOC,YAAQJ,GACrBK,KAAKC,WAAWH,EAAKI,aAMrBF,KAAKoC,mBAAqBhC,YACtBT,EACA,sBAEPK,KAAKqC,UAAYjC,YACVT,EACA,a,8CA+CR,SAAWY,GAiBT,GAfAC,YAAWD,EAAQ,CAAC,qBAAsB,eAepB,IAXTE,YACXF,EACAA,EACA4B,EAAc5B,OAAO,CACnBG,MAAO,CACL0B,mBAAoB,qBACpBC,UAAW,gBAKRzB,SACP,MAAM,IAAIC,MACR,kF,qBA/CN,WAAgC,IAAlBkB,EAAiB,uDAAJ,GAMnBrB,EAAQN,YAAmB2B,EAAY,QAAS,IAEtD,OAAO,IAAIP,IAAS,CAClBQ,KAAMtB,EAAMuB,WAAa,GACzBC,UAAU,EACVb,MAAO,CACX3B,IAAoBa,OACnBG,EAAM0B,oBAAsB,CAC1B1B,MAAO,CACRuB,UAAW,wBAIP,IAAIK,IAAU,CAAEN,KAAM,qB,+IC7ExBO,EAAiB,SAACC,GACtB,IAAIC,EAAY,GAiBhB,MAfgB,kBAAZD,EACFC,EAAY,CACVC,kBAAmB,+BACnBC,YAAa,8CACbC,aAAc,SACdC,gBAAiB,SACjBC,sBAAuB,SACvBC,YAAa,KACbC,YAAaC,IACbC,qBAAsB,WACtBC,2BAA4B,aAG9BC,QAAQC,IAAI,mDAEPZ,GAGIa,EAAb,WAEE,aAAgF,IAAD,OAAnEC,EAAmE,uDAA1D,GAAIf,EAAsD,uCAA7CgB,EAA6C,uDAAnC,CAAEC,wBAAwB,GAAS,oBAExEjB,GAASY,QAAQC,IAAI,+CAK1B,IAAIZ,EAAYF,EAAeC,GAmC/B,GAhCAxC,KAAKyD,uBAAyBD,EAAQC,uBAGtCzD,KAAK0D,sBAAwBF,EAAQC,6BAAgCE,EAErE3D,KAAK4D,eAAgB,EACrB5D,KAAKuD,OAASA,EAEdvD,KAAK6D,aAAepB,EAAUE,YAC9B3C,KAAK8D,MAAQ,EACb9D,KAAK+D,iBAAmB,EACxB/D,KAAK2C,YAAcF,EAAUE,YAC7B3C,KAAK0C,kBAAoBD,EAAUC,kBACnC1C,KAAK4C,aAAeH,EAAUG,aAC9B5C,KAAK6C,gBAAkBJ,EAAUI,gBACjC7C,KAAK+C,YAAcN,EAAUM,YAC7B/C,KAAK8C,sBAAwBL,EAAUK,sBACvC9C,KAAKgD,YAAcP,EAAUO,YAC7BhD,KAAKkD,qBAAuBT,EAAUS,qBACtClD,KAAKmD,2BAA6BV,EAAUU,2BAC5CnD,KAAKgE,eAAiB,KAEtBhE,KAAKiE,YAAc,EACnBjE,KAAKkE,MAAQ,KACblE,KAAKmE,SAAW,qBAEZX,EAAQY,eAAe,WAAUpE,KAAK8D,MAAQN,EAAQM,OACtDN,EAAQY,eAAe,uBAAsBpE,KAAK0C,kBAAoBc,EAAQd,mBAC9Ec,EAAQY,eAAe,iBAAgBpE,KAAK2C,YAAca,EAAQb,aAEtE3C,KAAKqE,sBAAuB,EAExBrE,KAAK0C,kBAAmB,CAE1B,IAAI4B,EAAa,IAAIC,IAAIC,OAAOC,SAASC,MACrCC,EAAkB,IAAIJ,IAAIvE,KAAK6D,cAE/BS,EAAWM,SAAWD,IAGxB3E,KAAKqE,sBAAuB,EAC5BrE,KAAK6E,gBAGP7E,KAAK8E,2BAA0B,SAAAC,GAC7B,GAAIA,EAAMH,SAAWD,EAAgBC,QAGjCG,EAAMC,KAAKC,eAA6C,WAA5BF,EAAMC,KAAKC,eAA8B,EAAKjB,eAAgB,CAC5F,EAAKA,eAAekB,SACpB,IAAMC,EAAa,IAAIC,MAAM,iBAC7BC,SAASC,KAAKC,cAAcJ,OAQlC,GAAIX,SAAWA,OAAOgB,OAAQ,CAC5BxF,KAAK8D,OAASV,QAAQC,IAAI,4DAG1BrD,KAAK8E,0BAA0B9E,KAAKyF,wBAAwBC,KAAK1F,OAGjE,IAAI2F,EAAW,IAAIpB,IAAIc,SAASM,UAChCnB,OAAOgB,OAAOI,YAAY,CAAEX,cAAe,cAAeY,WAAY,IAAMF,EAASf,SA/E3F,uGAoFE,4BAAAkB,EAAA,yDAEOtB,OAAOuB,SAFd,sBAGU,IAAIlF,MAAM,mCAHpB,uBAO8B2D,OAAOuB,SAASC,QAAQ,CAAEC,OAAQ,wBAPhE,WAOQC,EAPR,SAQyBA,EAAcC,OARvC,sBASU,IAAItF,MAAM,0BATpB,gCAYSqF,EAAc,IAZvB,2CApFF,uIAmGE,WAAmCE,GAAnC,iBAAAN,EAAA,sEACQ9F,KAAKqG,+BADb,cAGMC,EAAW,IAAIC,IAAOC,UAAUC,aAAajC,OAAOuB,UACpDW,EAASJ,EAASK,YAJxB,SAKeD,EAAOE,YAAYR,GALlC,wFAnGF,0FA2GE,SAAsBS,GACpBzD,QAAQC,IAAI,iCAAmCwD,GAI/C,IAAMC,EAASzB,SAAS0B,cAAc,UACtC/G,KAAKgE,eAAiB8C,EACtBA,EAAOE,IAAMH,EACbC,EAAOG,MAAMC,MAAQ,MACrBJ,EAAOG,MAAME,OAAS,MACtBL,EAAOG,MAAMG,QAAU,EAKvB/B,SAASC,KAAK+B,YAAYP,KA1H9B,+BA8HE,SAAkBQ,GAChBtH,KAAK0D,qBAAuB4D,IA/HhC,+BAmIE,WACE,OAAOtH,KAAK0D,uBApIhB,qCAuIE,SAAwBqB,GAGtB,IAAIY,EAAW,IAAIpB,IAAIc,SAASM,UAChC,GAAIZ,EAAMH,SAAWe,EAASf,QAQQ,qBAA7BG,EAAMC,KAAKuC,eACkB,qBAA1BxC,EAAMC,KAAKwC,WAFvB,CAQA,IAAIC,EAAU1C,EAAMC,KAAKuC,cAGrBvC,EAAOD,EAAMC,KAAKwC,WAItB,OAFApE,QAAQC,IAAI,2BAA4BoE,EAASzC,GAEzCyC,GACN,IAAK,YAEH,GAAoC,qBAAzBjD,OAAOkD,cAEhB,YADAtE,QAAQC,IAAI,8BAId,IAAIsE,EAAe3H,KAAK4H,YAAY5C,GAEhC6C,EAAeF,EAAaG,MAC5BC,EAAeJ,EAAaK,OAChChI,KAAKiI,cAAgB,IAAIP,cAAc1H,MAEvC,IAAIkI,EAAW,CACbC,WAAYN,EACZE,aAAcA,EACdrF,kBAAmB1C,KAAK0C,mBAEtBiF,GAAgBA,EAAaS,KAAIF,EAASG,MAAQV,EAAaS,IAC/DT,GAAgBA,EAAaW,aAAYJ,EAASrB,UAAYc,EAAaW,YAE/EtI,KAAKiI,cAAcM,sBAAsBL,GACvC,SAAAM,GACEpF,QAAQC,IAAI,eAAgBmF,GAC5BhE,OAAOgB,OAAOI,YAAY,CAAEX,cAAe,eAAgBY,WAAY,CAAE4C,SAAUD,EAAKpC,QAAS,GAAIsC,UAAWF,IAAS7C,EAASf,WAEtI,MACF,IAAK,aAGH5E,KAAK2I,2BAhMb,kCAuME,WACE,IAAIhD,EAAW,IAAIpB,IAAIc,SAASM,UAChCnB,OAAOgB,OAAOI,YAAY,CAAEX,cAAe,aAAcY,WAAY,QAAUF,EAASf,UAzM5F,+BA4ME,WACE,IAAIe,EAAW,IAAIpB,IAAIc,SAASM,UAChCnB,OAAOgB,OAAOI,YAAY,CAAEX,cAAe,aAAcY,WAAY,QAAUF,EAASf,UA9M5F,kCAiNE,WACE,IAAIgE,EAAe5I,KAAK6I,aACxB,GAAID,EAAaF,UAAYE,EAAaE,SAAU,CAClD,IAAIC,EAAgB/I,KAAKgJ,aAAaJ,EAAaK,QAC/CC,EAAiBlJ,KAAKmJ,aAAaJ,GACvCH,EAAaK,OAASC,EAExB,IAAIvD,EAAW,IAAIpB,IAAIc,SAASM,UAChCnB,OAAOgB,OAAOI,YAAY,CAAEX,cAAe,aAAcY,WAAY+C,GAAgBjD,EAASf,UAzNlG,0BA4NE,WACE,IAAMwE,EAAY,IAAIC,gBAAgB7E,OAAOC,SAAS6E,QAChDC,EAAiBH,EAAUI,IAAIxJ,KAAK4C,cACpC6G,EAAkBL,EAAUI,IAAIxJ,KAAK6C,iBACrC6G,EAAcN,EAAUI,IAAIxJ,KAAK+C,aAEvC,GAAMwG,GAAkBE,EAAxB,CAKA,IAAIb,EAAe5I,KAAK6I,aACpBI,EAAS,GAETU,GAAmB,EA2BvB,GAzBKf,EAAaE,WAEhBG,EAASL,EAAaK,QAEfW,KAAI,SAAAC,GACLA,EAAU/B,QAAUyB,IACtBI,GAAmB,MAQrBA,GACFV,EAAO9H,KAAK,CACV2G,MAAOyB,EACPvB,OAAQyB,EACRrB,GAAIsB,EACJpB,WAAY9D,OAAOC,SAASC,OAIhCoF,aAAaC,QAAQ/J,KAAKkD,qBAAsBvB,KAAKC,UAAUqH,IAE3DzE,SAAWA,OAAOgB,OAAQ,CAC5BxF,KAAK8D,OAASV,QAAQC,IAAI,yCAG1B,IAAIsC,EAAW,IAAIpB,IAAIc,SAASM,UAChCnB,OAAOgB,OAAOI,YAAY,CAAEX,cAAe,WAAaU,EAASf,YA1QvE,0BAiRE,SAAamE,GAA6B,IAAD,OAAbxF,EAAa,uDAAJ,GACD,GAA9ByG,OAAOC,KAAK1G,GAAQ4C,SACtB5C,EAASvD,KAAKuD,QAEhB,IAAIiF,EAAM,GACV,GACEO,EAAc5C,QACO,kBAAX5C,GACPyG,OAAOC,KAAK1G,GAAQ4C,OACvB,CACA,IAAI+D,EAAaF,OAAOC,KAAK1G,GAY7B,OAXAwF,EAAcoB,SAAQ,SAAArC,GACpB,IAAIsC,EAAY,EAChB,EAAKtG,OAASV,QAAQC,IAAI,cAAeyE,GACzCoC,EAAWC,SAAQ,SAAAE,GACbvC,EAAMuC,GAAKrJ,YAAcuC,EAAO8G,GAAKrJ,aAAYoJ,EAAY,MAE/DA,IACF5B,EAAIrH,KAAK2G,GACT,EAAKhE,OAASV,QAAQC,IAAI,cAAeyE,OAGtCU,EAEP,OAAOO,IAzSb,4BA6SE,SAAeuB,EAAIC,GACjB,IAAK,IAAIC,KAAKF,EACZ,GAAIA,EAAGlG,eAAeoG,IAChBF,EAAGE,GAAGxJ,aAAeuJ,EAAGC,GAAGxJ,WAC7B,OAAO,EAIb,IAAK,IAAIwJ,KAAKD,EACZ,GAAIA,EAAGnG,eAAeoG,IAChBF,EAAGE,GAAGxJ,aAAeuJ,EAAGC,GAAGxJ,WAC7B,OAAO,EAIb,OAAO,IA5TX,wBAgUE,WACE,IAAMyJ,EAAiBX,aAAaY,QAAQ1K,KAAKkD,sBAC7C+F,EAAS,GACT0B,EAAS,CAAE1B,OAAQ,GAAIH,UAAU,EAAMJ,SAAS,GACpD,IACM+B,GAAkBA,EAAetE,SAGb,KADtB8C,EAAStH,KAAKiJ,MAAMH,IACTtE,QAGT8C,EAAOkB,SAAQ,SAAAU,GACTA,EAAK/C,OAAS+C,EAAK7C,QACrB2C,EAAO1B,OAAO9H,KAAK0J,MAQrBF,EAAO1B,OAAO9C,SAChBwE,EAAO7B,UAAW,IAGtB,MAAOgC,GACP1H,QAAQC,IAAI,qCACY,oBAAb0H,WACTJ,EAAOjC,SAAU,GAGrB,OAAOiC,IA/VX,yBAkWE,SAAYK,GAAgB,IAAD,OACrBpC,EAAe5I,KAAK6I,aACxB,GAAID,EAAaF,UAAYE,EAAaE,SAAU,CAClD,IAAImC,EAAYrC,EAAaK,OAEzBnB,GAAQ,EAsBZ,OApBImD,EAAU9E,QACZ8E,EAAUd,SAAQ,SAAAN,GAChB,GAAIA,EAAU/B,MAAO,CAEnB,IAAIoD,EAAe,IAAI,EAAKlI,YAAY,EAAKmI,mBAAmBtB,EAAU/B,OAAOsD,QACjF,GAAIF,GAAgBA,EAAa,EAAKpI,uBAAwB,CAC5D,IAAIuI,EAAmBH,EAAa,EAAKpI,uBAErC,EAAKwI,eAAeD,EAAkBL,KACxClD,EAAQ+B,SAKZzG,QAAQC,IAAI,gCAMXyE,KA7Xb,qCAiYE,SAAwB/C,GAItB,IAAIJ,EAAkB,IAAIJ,IAAIvE,KAAK6D,cAGnC,GAAIkB,EAAMH,SAAWD,EAAgBC,QAQC,qBAA7BG,EAAMC,KAAKC,eACkB,qBAA1BF,EAAMC,KAAKa,WAFvB,CASA,IAAI4B,EAAU1C,EAAMC,KAAKC,cAGrBD,EAAOD,EAAMC,KAAKa,WAItB,OAFAzC,QAAQC,IAAI,2BAA4BoE,EAASzC,GAEzCyC,GACN,IAAK,aACS,QAARzC,EACFhF,KAAKuL,gBAAgBtE,MAAMuE,QAAU,QACpB,QAARxG,IACThF,KAAKuL,gBAAgBtE,MAAMuE,QAAU,QAEvC,MACF,IAAK,aAEHxL,KAAKyL,0BAA0BzL,KAAK0L,yBAEpC1L,KAAKuL,gBAAgBrG,SAEjBF,EAAK0D,UAAY1D,EAAK8D,WACxB9D,EAAKiE,OAASjJ,KAAKmJ,aAAanE,EAAKiE,SAEvCjJ,KAAK2L,kBAAkB3G,GACvB,MAEF,IAAK,eAEHhF,KAAKuL,gBAAgBrG,SAErBlF,KAAK4L,cAAgB5L,KAAK4L,aAAa5G,GACvChF,KAAK4L,cAAe,EACpB,MAEF,IAAK,cACC7G,GAASA,EAAMpF,SACjBoF,EAAMpF,OAAOiG,YAAY5F,KAAK4D,cAAemB,EAAMH,QACnD5E,KAAK4D,cAAgB,QA9b/B,0BA0cE,YAA2C,IAAD,OAA5BoH,EAA4B,EAA5BA,cAAea,EAAa,EAAbA,WAC3B,OAAO,IAAIC,QAAJ,uCAAY,WAAOC,EAASC,GAAhB,SAAAlG,EAAA,sEACX,EAAKmG,cAAcjB,EAAea,GAAY,SAACK,EAAOC,GAC1D,IAAKD,IAAU,EAAKE,UAAW,OAAOJ,EAAOG,GAC7CJ,EAAQ,CAAEG,QAAOE,UAAW,EAAKA,UAAWC,QAAQ,OAHrC,2CAAZ,2DA3cX,kEAodE,WAAoBrB,EAAea,EAAYD,GAA/C,eAAA9F,EAAA,6DACE1C,QAAQC,IAAI,2DADd,kBAIsBrD,KAAKsM,qBAJ3B,OAIIF,EAJJ,8DAMIR,EAAa,KAAD,MANhB,2BAUExI,QAAQC,IAAI,YAAa+I,GAEzBpM,KAAKoM,UAAYA,EAEjBpM,KAAK4L,aAAeA,EAEpB5L,KAAK4D,cAAgB,CAAE2D,cAAe,YAAaC,WAAYwD,GAC/DhL,KAAKuM,eAjBP,yDApdF,sFAweE,SAAcC,GACZ,IAAIC,EAAQ,GACRC,EAAI,EACR,GACED,IAAQC,GAAU,IAALF,EACbA,IAAS,QACFE,GACT,OAAOD,IA/eX,2EAkfE,WAA6BE,GAA7B,iBAAA7G,EAAA,6DAGQ8G,EAASC,KAAKC,MAAqB,IAAb9M,KAAKkE,MAC7B6I,EAASC,KAAKC,MAAMD,KAAKD,SAALC,KAAA,IAAiB,GAAMhN,KAAKiE,cAJtD,kBAMS,CACLiJ,GAAIH,EAAO/L,WAAahB,KAAKmN,WAAWJ,EAAQH,GAChDQ,OAAQR,IARZ,gDAlfF,+EA8fE,SAAWG,EAAQH,GACjB,IAAIS,EAAyBrN,KAAKsN,cAAcP,GAAQQ,OAAOvN,KAAKsN,cAAcV,IAClF,OAAOrG,IAAOiH,MAAMC,YAAY,SAAUzN,KAAKmE,SAAUkJ,KAhgB7D,2BAmgBE,SAAcK,GACZ,IAAIX,EAASY,SAASD,EAAOR,GAAGU,OAAO,EAAGF,EAAOR,GAAG/G,OAAS,KAE7D,OADWnG,KAAKmN,WAAWJ,EAAQW,EAAOd,UAC7Bc,EAAOR,GAAGU,OAAOF,EAAOR,GAAG/G,OAAS,OAC7CuH,EAAOd,OAASC,KAAKC,SAvgB7B,uEA2gBE,WAAyBjB,GAAzB,qBAAA/F,EAAA,6DAEQ+H,EAAiB/D,aAAaY,QAAQ1K,KAAKmD,4BAI/C2K,EADED,GAAkBA,EAAe1H,OACzBxE,KAAKiJ,MAAMiD,GAEX,GARd,SAWsB7N,KAAKqG,+BAX3B,UAYE0H,GADIA,EAXN,QAYoBC,cAIdF,GAAWA,EAAQC,KAAa/N,KAAKiO,cAAcH,EAAQC,MAC7D3K,QAAQC,IAAI,mCACLyK,EAAQC,KAGbD,IAAWA,EAAQC,GArBzB,iBAsBI3B,EAAY0B,EAAQC,GAtBxB,yCAwBsB/N,KAAKkO,iBAAiBrC,GAxB5C,SAwBIO,EAxBJ,UA0BM0B,EAAQ1B,EAAU2B,QAAQC,eAAiB5B,EAC3CtC,aAAaC,QAAQ/J,KAAKmD,2BAA4BxB,KAAKC,UAAUkM,KA3B3E,iCA8BS1B,GA9BT,iDA3gBF,4HA4iBE,WAAuBP,GAAvB,+BAAA/F,EAAA,sEAC+B9F,KAAKmO,uBAAuBtC,GAD3D,uBACUqB,EADV,EACUA,GAAIE,EADd,EACcA,OAENgB,EAAS5J,OAAOC,SAAS4J,SAEzBC,EALR,2CAKwDF,EALxD,yDAK+GlB,EAAGlM,WALlH,sBAOwBhB,KAAKuO,6BAA6BD,GAP1D,cAOME,EAPN,OAQQC,EAAUlI,IAAOiH,MAAMkB,YAAYJ,GACnCK,EAAepI,IAAOiH,MAAMoB,SAASH,GAErCI,EAAmBtI,IAAOiH,MAAMsB,eAAeH,EAAcH,GAXrE,kBAaS,CACLT,QAASc,EACTjC,OAAQQ,EACRkB,YACAE,YACAtB,OAlBJ,iDA5iBF,8EAkkBE,WAAa,IAAD,OACV,OAAO,IAAIpB,SAAQ,SAACC,EAASC,GAC3B,EAAK+C,YAAW,SAAC9F,GACf,IAAKA,EAAQ,OAAO+C,GAAO,GAC3BD,EAAQ9C,WAtkBhB,+BA2kBE,WAAqB,IAAD,OAClB,OAAO,IAAI6C,SAAQ,SAACC,EAASC,GAC3B,EAAK+C,YAAW,SAAC9F,GACf,IAAKA,EAAQ,OAAO+C,GAAO,GAC3BD,EAAQ9C,WA/kBhB,wBAolBE,SAAW8B,GAET,IAAkC,IAA9B/K,KAAK0D,qBACP,OAAO,EAIT,GAFA1D,KAAK2L,kBAAoBZ,EAErB/K,KAAK0C,kBAIP,GAFAU,QAAQC,IAAI,oBAAqBrD,KAAK0C,mBAElC8B,OAAOC,SAASC,OAAS1E,KAAK6D,aAAc,CAE9C,IAAI+E,EAAe5I,KAAK6I,aACxB,GAAID,EAAaF,UAAYE,EAAaE,SAAU,CAClD,IAAIC,EAAgB/I,KAAKgJ,aAAaJ,EAAaK,QAC/CC,EAAiBlJ,KAAKmJ,aAAaJ,GACvCH,EAAaK,OAASC,EACtBlJ,KAAK2L,kBAAkB/C,SAGzB5I,KAAK4D,cAAgB,CAAE2D,cAAe,aAAcC,WAAY,IAChExH,KAAKuM,oBAGPnJ,QAAQC,IAAI,6BA7mBlB,0BAknBE,WACED,QAAQC,IAAI,sBAEZrD,KAAK8E,0BAA0B9E,KAAK0L,wBAAwBhG,KAAK1F,OAEjE,IAAM8G,EAASzB,SAAS0B,cAAc,UACtC/G,KAAK8G,OAASA,EACdA,EAAOE,IAAMhH,KAAK6D,aAClBiD,EAAOG,MAAMC,MAAQ,QACrBJ,EAAOG,MAAME,OAAS,QACtBL,EAAOG,MAAM+H,SAAW,OACxBlI,EAAOG,MAAMgI,WAAa,OAC1B,IAAIC,EAAa7J,SAAS0B,cAAc,OACxC/G,KAAKuL,gBAAkB2D,EACvBA,EAAWC,aAAa,QAAS,mJACjCD,EAAW7H,YAAYP,GACvBzB,SAASC,KAAK+B,YAAY6H,KAloB9B,gCAqoBE,SAAmBE,GAYjB,OAVAA,EAAYA,EAAUC,MAAM,KAAKC,KAAK,KACnCD,MAAM,KAAKC,KAAK,KAChBD,MAAM,KAAKC,KAAK,KAGG,qBAAXC,EACHC,WAAWC,KAAKF,EAAOE,KAAKL,EAAW,WAEvCI,WAAWC,KAAKC,KAAKN,IAAY,SAAAO,GAAC,OAAIA,EAAEC,WAAW,QA/oB/D,0BAopBE,SAAa3E,GAAY,IAAD,OAClBjL,KAAK8D,QACPV,QAAQC,IAAI,sBACZD,QAAQC,IAAI4H,IAEd,IAAIlC,EAAgB,GAYpB,OAXIkC,EAAU9E,QACZ8E,EAAUd,SAAQ,SAAAN,GAChB,GAAIA,EAAU/B,MAAO,CACnB,IAAIoD,EAAe,IAAI,EAAKlI,YAAY,EAAKmI,mBAAmBtB,EAAU/B,OAAOsD,QAC7EF,GAAgBA,EAAa,EAAKpI,wBAAwBiG,EAAc5H,KAAK+J,EAAa,EAAKpI,6BAEnGM,QAAQC,IAAI,gCAKX0F,IArqBX,uCAwqBE,SAA0B8G,GACpBrL,OAAOsL,iBACTtL,OAAOsL,iBAAiB,UAAWD,GAAU,GAG7CrL,OAAOuL,YAAY,YAAaF,KA7qBtC,uCAgrBE,SAA0BA,GACpBrL,OAAOsL,iBACTtL,OAAOwL,oBAAoB,UAAWH,GAAU,GAGhDrL,OAAOyL,YAAY,YAAaJ,OArrBtC,O,yJCZaK,EAAb,WAQE,aAA0B,IAAdvQ,EAAa,uDAAJ,GACnB,GADuB,oBACA,iBAAXA,EACV,MAAM,IAAIC,UAAU,4CAEtB,GAAID,aAAkBE,YAAa,CACjC,IAAMC,EAAOC,YAAQJ,GACrBK,KAAKC,WAAWH,EAAKI,aAErBF,KAAKmQ,SAAW/P,YACZT,EACA,YAEJK,KAAKoQ,SAAWhQ,YACZT,EACA,YAEJK,KAAKqQ,YAAcjQ,YACfT,EACA,eA1BV,8CAuDE,SAAWY,GAETC,YAAWD,EAAQ,CAEjB,WACA,WACA,gBAKF,IAAMT,EAAOW,YAAcF,EAAQA,EAAQ2P,EAAa3P,UAExD,IAAsB,IAAlBT,EAAKc,SACP,MAAM,IAAIC,MAAM,wEAWlB,GAJI,aAAcf,EAAKI,SACrBF,KAAKmQ,SAAWrQ,EAAKI,OAAL,SAAwBa,WAAWM,OAGjD,aAAcvB,EAAKI,OAAQ,CAC7B,IAAMkQ,EAAWtQ,EAAKI,OAAL,SAAwBa,WAAWuP,UACpDtQ,KAAKoQ,SAAWG,OAAO,KAAOC,YAAiBJ,IAGjD,GAAI,gBAAiBtQ,EAAKI,OAAQ,CAChC,IAAMmQ,EAAcvQ,EAAKI,OAAL,YAA2Ba,WAAWuP,UAC1DtQ,KAAKqQ,YAAcE,OAAO,KAAOC,YAAiBH,QAvFxD,qBA+BE,WAAgC,IAAlBtO,EAAiB,uDAAJ,GACnBrB,EAAQN,YAAmB2B,EAAY,QAAS,IAEtD,OAAO,IAAIP,IAAS,CAClBQ,KAAMtB,EAAMuB,WAAa,SACzBZ,MAAO,CACL,IAAIoP,IAAW,CACbzO,KAAMtB,EAAMyP,UAAY,aAE1B,IAAIO,IAAQ,CACV1O,KAAMtB,EAAM0P,UAAY,aAE1B,IAAIM,IAAQ,CACV1O,KAAMtB,EAAM2P,aAAe,uBA5CrC,KA8FapN,EAAb,WAQE,aAA0B,IAAdtD,EAAa,uDAAJ,GACnB,GADuB,oBACD,iBAAXA,EAAqB,CAE9B,IAAMgR,EAAiBhR,EAAOiR,WAAW,YACpC,IAAIrM,IAAI5E,GAASkR,aAAarH,IAAI,UAAY7J,EAE/CyP,EAAYuB,EACXtB,MAAM,KAAKC,KAAK,KAChBD,MAAM,KAAKC,KAAK,KAChBD,MAAM,KAAKC,KAAK,KAInB3P,EADoB,qBAAX4P,EACAC,WAAWC,KAAKF,EAAOE,KAAKL,EAAW,WAAWhE,OAElDoE,WAAWC,KAAKC,KAAKN,IAAY,SAAAO,GAAC,OAAIA,EAAEC,WAAW,MAAIxE,OAKpE,GAAIzL,aAAkBE,YAAa,CACjC,IAAMC,EAAOC,YAAQJ,GACrBK,KAAKC,WAAWH,EAAKI,aAErBF,KAAK8Q,OAAS,IAAIZ,EAAavQ,EAAOmR,QAEtC9Q,KAAK+Q,WAAa3Q,YACdT,EACA,cAMPK,KAAKgR,cAAgB,IAAI7O,IAAcxC,EAAOqR,eAE3ChR,KAAKiR,eAAiB7Q,YAClBT,EACA,kBA9CV,8CAgHE,SAAWY,GAETC,YAAWD,EAAQ,CAEjB,SACA,aAEH,gBACG,mBAKF,IAAMT,EAAOW,YAAcF,EAAQA,EAAQ0C,EAAmB1C,UAE9D,IAAsB,IAAlBT,EAAKc,SACX,MAAM,IAAIC,MAAM,8EAOdb,KAAK8Q,OAAS,IAAIZ,EAAapQ,EAAKI,OAAO4Q,OAAOI,mBAE9C,eAAgBpR,EAAKI,SACvBF,KAAK+Q,WAAajR,EAAKI,OAAL,WAA0Ba,WAAWoQ,UAI5DnR,KAAKgR,cAAgB,IAAI7O,IAAc,CAClC5B,OAAQT,EAAKI,OAAO8Q,gBAGtB,IAAMC,EAAiBnR,EAAKI,OAAO+Q,eACnCjR,KAAKiR,eAAiBA,EAAelQ,WAAWoQ,YAnJpD,qBAkEE,WAAgC,IAAlBpP,EAAiB,uDAAJ,GAOnBrB,EAAQN,YAAmB2B,EAAY,QAAS,IAEtD,OAAO,IAAIP,IAAS,CAClBQ,KAAMtB,EAAMuB,WAAa,qBACzBZ,MAAO,CACL6O,EAAa3P,OAAOwB,GACpB,IAAIqP,IAAY,CACdpP,KAAM,eAqBR,IAAIM,IAAU,CACZN,KAAM,0BAtGhB,O,gQChFeqP,MAtBf,YAAuC,IAAlBC,EAAiB,EAAjBA,cAGXjB,EAAoCiB,EAApCjB,YAAaD,EAAuBkB,EAAvBlB,SAAUD,EAAamB,EAAbnB,SAC/B,OACE,sBAAKoB,UAAU,kBAAf,UACE,sBAAKA,UAAU,gBAAf,UACE,cAACC,EAAA,EAAD,CAAYD,UAAU,cAAcE,QAAQ,KAAKC,UAAU,KAA3D,SACGrB,EAAYrP,aAEf,cAACwQ,EAAA,EAAD,CAAYD,UAAU,WAAWE,QAAQ,QAAQE,MAAM,gBAAgBD,UAAU,IAAjF,SACGtB,GAAYA,EAASpP,aAExB,eAACwQ,EAAA,EAAD,CAAYD,UAAU,WAAWE,QAAQ,QAAQE,MAAM,gBAAgBD,UAAU,IAAjF,wBACcvB,GAAYA,EAASnP,iBAGrC,qBAAKuQ,UAAU,YAAYvK,IAAI,iCCb/B4K,G,MAAiB,CACrB,CACEd,OAAQ,+MACR9I,OAAO,cACPI,GAAG,eAEL,CACE0I,OAAQ,mNACR9I,OAAO,cACPI,GAAG,eAEL,CACE0I,OAAQ,2MACR9I,OAAO,cACPI,GAAG,eAEL,CACE0I,OAAQ,2MACR9I,OAAO,cACPI,GAAG,iBAgGQyJ,MA5Ff,WAEKxM,SAASyM,kBACVzM,SAASyM,mBAAmBC,MAAK,SAACC,GAChC5O,QAAQC,IAAI,gBAAiB2O,GACxBA,GACH3M,SAAS4M,uBAAuBF,MAAK,SAAAG,GACnC9O,QAAQC,IAAI,6BAA8B6O,SAOlD,MAA0BC,mBAAS,IAAnC,mBAAKlJ,EAAL,KAAamJ,EAAb,KAKMC,EAAa,IAAI/O,IAHR,GACD,gBACE,IAGhBgP,oBAAS,sBAAC,4BAAAxM,EAAA,sEAEiBuM,EAAWE,YAF5B,QAEFC,EAFE,QAGM9J,SAAS0J,EAAUI,EAAWvJ,QAHpC,2CAIP,IAMH,IAAMwJ,EAAkB,uCAAG,qCAAA3M,EAAA,sDAAQf,EAAR,EAAQA,MAAO+L,EAAf,EAAeA,OAAQ9I,EAAvB,EAAuBA,OAAQI,EAA/B,EAA+BA,GACxDrD,EAAM2N,iBACA7L,EAFmB,6DAE+CiK,EAF/C,mBAEgE9I,EAFhE,eAE6EI,GACtGiK,EAAWM,sBAAsB9L,GAKjCwL,EAAWE,YAAYR,MAAK,SAAAvJ,GACvBA,EAAIE,SAAS0J,EAAU5J,EAAIS,WATP,2CAAH,sDAaxB,OACE,iCACE,mBAAGvE,KAAK,IAAR,SAAY,qBAAK6M,UAAU,OAAOvK,IAAI,mBACtC,qBAAKuK,UAAU,aAAf,SACE,+DAEF,qBAAKA,UAAU,aAAf,SACE,qBAAKA,UAAU,gBAAgBvK,IAAI,0BAErC,qBAAKuK,UAAU,aAAf,SACE,2KAEF,qBAAKA,UAAU,aAAf,SACE,gDAEF,qBAAKA,UAAU,aAAf,SACE,sBAAKA,UAAU,gBAAf,UAEItI,GAAUA,EAAO9C,OAAS,GAAK8C,EAAOW,KAAI,SAAC0H,EAAesB,GACxD,OAAO,cAAC,EAAD,CAAkBtB,cAAeA,GAAtBsB,OAInB3J,EAAO9C,QAAU,gCAChB,oDACA,iDACA,qBAAKoL,UAAU,gBAAf,SAEIK,EAAehI,KAAI,SAACiJ,EAAYD,GAC9B,OACE,wBAAoBrB,UAAU,aAAauB,QAAS,SAAA/N,GAAK,OAAI0N,EAAmB,CAC9E1N,QACA+L,OAAQ+B,EAAW/B,OACnB9I,OAAQ6K,EAAW7K,OACnBI,GAAIyK,EAAWzK,MAJjB,0BAAawK,oBC7FpBG,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBlB,MAAK,YAAkD,IAA/CmB,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCDdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFpO,SAASqO,eAAe,SAM1BX,M","file":"static/js/main.6cd99ea3.chunk.js","sourcesContent":["import { Any, compareSchema, ObjectIdentifier, Sequence } from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class AlgorithmIdentifier {\n  //**********************************************************************************\n  /**\n   * Constructor for AlgorithmIdentifier class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.algorithmId = getParametersValue(\n          source,\n          \"algorithmId\"\n      );\n\n      if (\"algorithmParams\" in source)\n        /**\n         * @type {Object}\n         * @desc Any algorithm source\n         */\n        this.algorithmParams = getParametersValue(\n            source,\n            \"algorithmParams\",\n            AlgorithmIdentifier.defaultValues(\"algorithmParams\")\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n   /* FIXME: algorithmParams is options hence not removed and we need to complete this with all parameters with their default value covered here.\n   */\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithmParams\":\n        return new Any();\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return memberValue === \"\";\n      case \"algorithmParams\":\n        return memberValue instanceof asn1js.Any;\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * AlgorithmIdentifier  ::=  Sequence  {\n   *    algorithm               OBJECT IDENTIFIER,\n   *    parameters              ANY DEFINED BY algorithm OPTIONAL  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\n     * @property {string} algorithmParams Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || false,\n      value: [\n        new ObjectIdentifier({ name: names.algorithmIdentifier || \"algorithm\" }),\n        new Any({ name: names.algorithmParams || \"parameters\", optional: true }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"algorithm\", \"params\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      AlgorithmIdentifier.schema({\n        names: {\n          algorithmIdentifier: \"algorithm\",\n          algorithmParams: \"params\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n\n    //region Get internal properties from parsed schema\n    this.algorithmId = asn1.result.algorithm.valueBlock.toString();\n    if (\"params\" in asn1.result) this.algorithmParams = asn1.result.params;\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    outputArray.push(new ObjectIdentifier({ value: this.algorithmId }));\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      outputArray.push(this.algorithmParams);\n    //endregion\n\n    //region Construct and return new ASN.1 schema for this object\n    return new Sequence({\n      value: outputArray,\n    });\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n  toJSON() {\n    const object = {\n      algorithmId: this.algorithmId,\n    };\n\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      object.algorithmParams = this.algorithmParams.toJSON();\n\n    return object;\n  }\n  //**********************************************************************************\n  /**\n   * Check that two \"AlgorithmIdentifiers\" are equal\n   * @param {AlgorithmIdentifier} algorithmIdentifier\n   * @returns {boolean}\n   */\n  isEqual(algorithmIdentifier) {\n    //region Check input type\n    if (algorithmIdentifier instanceof AlgorithmIdentifier === false)\n      return false;\n    //endregion\n\n    //region Check \"algorithm_id\"\n    if (this.algorithmId !== algorithmIdentifier.algorithmId) return false;\n    //endregion\n\n    //region Check \"algorithm_params\"\n    if (\"algorithmParams\" in this) {\n      if (\"algorithmParams\" in algorithmIdentifier)\n        return (\n          JSON.stringify(this.algorithmParams) ===\n          JSON.stringify(algorithmIdentifier.algorithmParams)\n        );\n\n      return false;\n    }\n\n    if (\"algorithmParams\" in algorithmIdentifier) return false;\n    //endregion\n\n    return true;\n  }\n  //**********************************************************************************\n}\n//**************************************************************************************\n","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER,\n  Any,\n  ObjectIdentifier\n} from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class PublicKeyInfo {\n  //**********************************************************************************\n  /**\n   * Constructor for PublicKeyInfo class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Not accepting string. For base64, convert to ArrayBuffer.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.signatureAlgorithm = getParametersValue(\n          source,\n          \"signatureAlgorithm\"\n      );\n\t  this.publicKey = getParametersValue(\n          source,\n          \"publicKey\"\n      );\n    }\n  }\n \n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * PublicKeyInfo  ::=  Sequence  {\n   *    signatureAlgorithm               AlgorithmIdentifier,\n   *    publicKey              BIT-STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} signatureAlgorithm ObjectIdentifier for the algorithm\n     * @property {string} publicKey Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: true,\n      value: [\n\t\tAlgorithmIdentifier.schema(\n\t\t\tnames.signatureAlgorithm || {\n\t\t\t  names: {\n\t\t\t\tblockName: \"signatureAlgorithm\",\n\t\t\t  },\n\t\t\t}\n\t\t),\n        new BitString({ name: \"publicKey\"}),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"signatureAlgorithm\", \"publicKey\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      PublicKeyInfo.schema({\n        names: {\n          signatureAlgorithm: \"signatureAlgorithm\",\n          publicKey: \"publicKey\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n  }\n}\n//**************************************************************************************\n","import { SignedDevconTicket } from './../Attestation/SignedDevonTicket';\nimport { ethers } from \"ethers\";\n\nconst getTokenConfig = (tokenId) => {\n  let XMLconfig = {};\n  // this will come from a lookup table at a later stage.\n  if (tokenId === \"devcon-ticket\") {\n    XMLconfig = {\n      attestationOrigin: \"https://stage.attestation.id\",\n      tokenOrigin: \"https://devcontickets.herokuapp.com/outlet/\",\n      tokenUrlName: 'ticket',\n      tokenSecretName: 'secret',\n      unsignedTokenDataName: 'ticket',\n      tokenIdName: 'id',\n      tokenParser: SignedDevconTicket,\n      localStorageItemName: 'dcTokens',\n      localStorageEthKeyItemName: 'dcEthKeys',\n    };\n  } else {\n    console.log(\"Negotiator: missing token script for this token\");\n  }\n  return XMLconfig;\n}\n\nexport class Negotiator {\n\n  constructor(filter = {}, tokenId, options = { userPermissionRequired: false }) {\n\n    if (!tokenId) console.log(\"Negotiator: tokenId is a required parameter\");\n\n    // The XML config is used to define the token configuration.\n    // This includes how the ticket will confirm its vailidity and the origin\n    // of where the ticket was issued from.\n    let XMLconfig = getTokenConfig(tokenId);\n    // When True, the negoticator will require userPermissionStatus to be true to\n    // read and provide tokens to client.\n    this.userPermissionRequired = options.userPermissionRequired;\n    // When userPermissionRequired is false, this flag defaults to true. Where \n    // no permission (input from user) is required.\n    this.userPermissionStatus = !options.userPermissionRequired ? true : undefined;\n    // TODO annotate the usage of variables below.\n    this.queuedCommand = false;\n    this.filter = filter;\n    //\n    this.tokensOrigin = XMLconfig.tokenOrigin;\n    this.debug = 0;\n    this.hideTokensIframe = 1;\n    this.tokenOrigin = XMLconfig.tokenOrigin;\n    this.attestationOrigin = XMLconfig.attestationOrigin;\n    this.tokenUrlName = XMLconfig.tokenUrlName;\n    this.tokenSecretName = XMLconfig.tokenSecretName;\n    this.tokenIdName = XMLconfig.tokenIdName;\n    this.unsignedTokenDataName = XMLconfig.unsignedTokenDataName;\n    this.tokenParser = XMLconfig.tokenParser;\n    this.localStorageItemName = XMLconfig.localStorageItemName;\n    this.localStorageEthKeyItemName = XMLconfig.localStorageEthKeyItemName;\n    this.addTokenIframe = null;\n\n    this.maxUNlength = 6;\n    this.UNttl = 60 * 60;\n    this.UNsecret = \"0x1234567890abcdef\";\n\n    if (options.hasOwnProperty('debug')) this.debug = options.debug;\n    if (options.hasOwnProperty('attestationOrigin')) this.attestationOrigin = options.attestationOrigin;\n    if (options.hasOwnProperty('tokenOrigin')) this.tokenOrigin = options.tokenOrigin;\n\n    this.isTokenOriginWebsite = false;\n\n    if (this.attestationOrigin) {\n      // if attestationOrigin filled then token need attestaion\n      let currentURL = new URL(window.location.href);\n      let tokensOriginURL = new URL(this.tokensOrigin);\n\n      if (currentURL.origin === tokensOriginURL) {\n        // its tokens website, where tokens saved in localStorage\n        // lets chech url params and save token data to the local storage\n        this.isTokenOriginWebsite = true;\n        this.readMagicUrl();\n      }\n\n      this.attachPostMessageListener(event => {\n        if (event.origin !== tokensOriginURL.origin) {\n          return;\n        }\n        if (event.data.iframeCommand && event.data.iframeCommand == \"closeMe\" && this.addTokenIframe) {\n          this.addTokenIframe.remove();\n          const tokenEvent = new Event('newTokenAdded');\n          document.body.dispatchEvent(tokenEvent);\n        }\n\n      })\n\n    }\n\n    // do we inside iframe?\n    if (window !== window.parent) {\n      this.debug && console.log('negotiator: its iframe, lets return tokens to the parent');\n\n      // its iframe, listen for requests\n      this.attachPostMessageListener(this.listenForParentMessages.bind(this))\n\n      // send ready message to start interaction\n      let referrer = new URL(document.referrer);\n      window.parent.postMessage({ iframeCommand: \"iframeReady\", iframeData: '' }, referrer.origin);\n    }\n\n  }\n\n  async connectMetamaskAndGetAddress() {\n\n    if (!window.ethereum) {\n      throw new Error('Please install metamask before.');\n    }\n\n    // const userAddresses = await window.ethereum.request({ method: 'eth_accounts' });\n    const userAddresses = await window.ethereum.request({ method: 'eth_requestAccounts' });\n    if (!userAddresses || !userAddresses.length) {\n      throw new Error(\"Active Wallet required\");\n    }\n\n    return userAddresses[0];\n  }\n\n  async signMessageWithBrowserWallet(message) {\n    await this.connectMetamaskAndGetAddress();\n\n    let provider = new ethers.providers.Web3Provider(window.ethereum);\n    let signer = provider.getSigner();\n    return await signer.signMessage(message);\n  }\n\n  addTokenThroughIframe(magicLink) {\n    console.log('createTokenIframe fired for : ' + magicLink);\n    // open iframe and request tokens\n    // this.attachPostMessageListener(this.listenForIframeMessages.bind(this));\n\n    const iframe = document.createElement('iframe');\n    this.addTokenIframe = iframe;\n    iframe.src = magicLink;\n    iframe.style.width = '1px';\n    iframe.style.height = '1px';\n    iframe.style.opacity = 0;\n    // let iframeWrap = document.createElement('div');\n    // this.tokenIframeWrap = iframeWrap;\n    // iframeWrap.setAttribute('style', 'width:100%; min-height: 100vh; position: fixed; align-items: center; justify-content: center; display: none; top: 0; left: 0; background: #fffa');\n    // iframeWrap.appendChild(iframe);\n    document.body.appendChild(iframe);\n  }\n\n  // Once a user has given or revoked their permission to use the token-negotiator\n  setUserPermission(bool) {\n    this.userPermissionStatus = bool;\n  }\n\n  // returns true / false\n  getUserPermission() {\n    return this.userPermissionStatus;\n  }\n\n  listenForParentMessages(event) {\n\n    // listen only parent\n    let referrer = new URL(document.referrer);\n    if (event.origin !== referrer.origin) {\n      return;\n    }\n\n    // console.log('iframe: event = ', event.data);\n\n    // parentCommand+parentData required for interaction\n    if (\n      typeof event.data.parentCommand === \"undefined\"\n      || typeof event.data.parentData === \"undefined\"\n    ) {\n      return;\n    }\n\n    // parentCommand contain command code\n    let command = event.data.parentCommand;\n\n    // parentData contains command content (token to sign or empty object)\n    let data = event.data.parentData;\n\n    console.log('iframe: command, data = ', command, data);\n\n    switch (command) {\n      case \"signToken\":\n        // we receive decoded token, we have to find appropriate raw token\n        if (typeof window.Authenticator === \"undefined\") {\n          console.log('Authenticator not defined.');\n          return;\n        }\n\n        let rawTokenData = this.getRawToken(data);\n\n        let base64ticket = rawTokenData.token;\n        let ticketSecret = rawTokenData.secret;\n        this.authenticator = new Authenticator(this);\n\n        let tokenObj = {\n          ticketBlob: base64ticket,\n          ticketSecret: ticketSecret,\n          attestationOrigin: this.attestationOrigin,\n        };\n        if (rawTokenData && rawTokenData.id) tokenObj.email = rawTokenData.id;\n        if (rawTokenData && rawTokenData.magic_link) tokenObj.magicLink = rawTokenData.magic_link;\n\n        this.authenticator.getAuthenticationBlob(tokenObj,\n          res => {\n            console.log('sign result:', res);\n            window.parent.postMessage({ iframeCommand: \"useTokenData\", iframeData: { useToken: res, message: '', success: !!res } }, referrer.origin);\n          });\n        break;\n      case \"tokensList\":\n        // TODO update\n        // console.log('let return tokens');\n        this.returnTokensToParent();\n        break;\n\n      default:\n    }\n  }\n\n  commandDisplayIframe() {\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"iframeWrap\", iframeData: 'show' }, referrer.origin);\n  }\n\n  commandHideIframe() {\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"iframeWrap\", iframeData: 'hide' }, referrer.origin);\n  }\n\n  returnTokensToParent() {\n    let tokensOutput = this.readTokens();\n    if (tokensOutput.success && !tokensOutput.noTokens) {\n      let decodedTokens = this.decodeTokens(tokensOutput.tokens);\n      let filteredTokens = this.filterTokens(decodedTokens);\n      tokensOutput.tokens = filteredTokens;\n    }\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"tokensData\", iframeData: tokensOutput }, referrer.origin);\n  }\n\n  readMagicUrl() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const tokenFromQuery = urlParams.get(this.tokenUrlName);\n    const secretFromQuery = urlParams.get(this.tokenSecretName);\n    const idFromQuery = urlParams.get(this.tokenIdName);\n\n    if (!(tokenFromQuery && secretFromQuery)) {\n      return;\n    }\n\n    // Get the current Storage Tokens\n    let tokensOutput = this.readTokens();\n    let tokens = [];\n\n    let isNewQueryTicket = true;\n\n    if (!tokensOutput.noTokens) {\n      // Build new list of tickets from current and query ticket { ticket, secret }\n      tokens = tokensOutput.tokens;\n\n      tokens.map(tokenData => {\n        if (tokenData.token === tokenFromQuery) {\n          isNewQueryTicket = false;\n        }\n      });\n\n    }\n\n    // Add ticket if new\n    // if (isNewQueryTicket && tokenFromQuery && secretFromQuery) {\n    if (isNewQueryTicket) {\n      tokens.push({\n        token: tokenFromQuery,\n        secret: secretFromQuery,\n        id: idFromQuery,\n        magic_link: window.location.href\n      }); // new raw object\n    }\n    // Set New tokens list raw only, websters will be decoded each time\n    localStorage.setItem(this.localStorageItemName, JSON.stringify(tokens));\n\n    if (window !== window.parent) {\n      this.debug && console.log('negotiator: its iframe, lets close it');\n\n      // send ready message to start interaction\n      let referrer = new URL(document.referrer);\n      window.parent.postMessage({ iframeCommand: \"closeMe\" }, referrer.origin);\n    }\n  }\n\n  /*\n    * Return token objects satisfying the current negotiator's requirements\n    */\n  filterTokens(decodedTokens, filter = {}) {\n    if (Object.keys(filter).length == 0) {\n      filter = this.filter;\n    }\n    let res = [];\n    if (\n      decodedTokens.length\n      && typeof filter === \"object\"\n      && Object.keys(filter).length\n    ) {\n      let filterKeys = Object.keys(filter);\n      decodedTokens.forEach(token => {\n        let fitFilter = 1;\n        this.debug && console.log('test token:', token);\n        filterKeys.forEach(key => {\n          if (token[key].toString() != filter[key].toString()) fitFilter = 0;\n        })\n        if (fitFilter) {\n          res.push(token);\n          this.debug && console.log('token fits:', token);\n        }\n      })\n      return res;\n    } else {\n      return decodedTokens;\n    }\n  }\n\n  compareObjects(o1, o2) {\n    for (var p in o1) {\n      if (o1.hasOwnProperty(p)) {\n        if (o1[p].toString() !== o2[p].toString()) {\n          return false;\n        }\n      }\n    }\n    for (var p in o2) {\n      if (o2.hasOwnProperty(p)) {\n        if (o1[p].toString() !== o2[p].toString()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // read tokens from local storage and return as object {tokens: [], noTokens: boolean, success: boolean}\n  readTokens() {\n    const storageTickets = localStorage.getItem(this.localStorageItemName);\n    let tokens = [];\n    let output = { tokens: [], noTokens: true, success: true };\n    try {\n      if (storageTickets && storageTickets.length) {\n        // Build new list of tickets from current and query ticket { ticket, secret }\n        tokens = JSON.parse(storageTickets);\n        if (tokens.length !== 0) {\n\n          // output.tokens = tokens;\n          tokens.forEach(item => {\n            if (item.token && item.secret) {\n              output.tokens.push(item)\n              // output.tokens.push({\n              //     token: item.token,\n              //     secret: item.secret\n              // })\n            }\n          })\n        }\n        if (output.tokens.length) {\n          output.noTokens = false;\n        }\n      }\n    } catch (e) {\n      console.log('Cant parse tokens in LocalStorage');\n      if (typeof callBack === \"function\") {\n        output.success = false;\n      }\n    }\n    return output;\n  }\n\n  getRawToken(unsignedToken) {\n    let tokensOutput = this.readTokens();\n    if (tokensOutput.success && !tokensOutput.noTokens) {\n      let rawTokens = tokensOutput.tokens;\n\n      let token = false;\n\n      if (rawTokens.length) {\n        rawTokens.forEach(tokenData => {\n          if (tokenData.token) {\n\n            let decodedToken = new this.tokenParser(this.base64ToUint8array(tokenData.token).buffer);\n            if (decodedToken && decodedToken[this.unsignedTokenDataName]) {\n              let decodedTokenData = decodedToken[this.unsignedTokenDataName];\n\n              if (this.compareObjects(decodedTokenData, unsignedToken)) {\n                token = tokenData;\n              }\n\n            }\n          } else {\n            console.log('empty token data received');\n          }\n\n        })\n      }\n\n      return token;\n    }\n  }\n\n  listenForIframeMessages(event) {\n\n    // console.log('listenForIframeMessages fired');\n\n    let tokensOriginURL = new URL(this.tokensOrigin);\n\n    // listen only tokensOriginURL\n    if (event.origin !== tokensOriginURL.origin) {\n      return;\n    }\n\n    // console.log('parent: event = ', event.data);\n\n    // iframeCommand required for interaction\n    if (\n      typeof event.data.iframeCommand === \"undefined\"\n      || typeof event.data.iframeData === \"undefined\"\n    ) {\n      return;\n    }\n\n    // iframeCommand contain command code\n\n    let command = event.data.iframeCommand;\n\n    // iframeData contains command content (tokens data, useToken , hide/display iframe)\n    let data = event.data.iframeData;\n\n    console.log('parent: command, data = ', command, data);\n\n    switch (command) {\n      case \"iframeWrap\":\n        if (data == \"show\") {\n          this.tokenIframeWrap.style.display = 'block';\n        } else if (data == \"hide\") {\n          this.tokenIframeWrap.style.display = 'none';\n        }\n        break;\n      case \"tokensData\":\n        // tokens received, disable listener\n        this.detachPostMessageListener(this.listenForIframeMessages);\n        // TODO remove iframeWraper\n        this.tokenIframeWrap.remove();\n\n        if (data.success && !data.noTokens) {\n          data.tokens = this.filterTokens(data.tokens);\n        }\n        this.negotiateCallback(data);\n        break;\n\n      case \"useTokenData\":\n\n        this.tokenIframeWrap.remove();\n\n        this.signCallback && this.signCallback(data);\n        this.signCallback = false;\n        break;\n\n      case \"iframeReady\":\n        if (event && event.source) {\n          event.source.postMessage(this.queuedCommand, event.origin);\n          this.queuedCommand = '';\n        }\n\n        break;\n\n      default:\n\n    }\n\n\n  }\n\n  authenticate({unsignedToken, unEndPoint}) {\n    return new Promise(async (resolve, reject) => {\n      await this._authenticate(unsignedToken, unEndPoint, (proof, error) => {\n        if (!proof || !this.useEthKey) return reject(error);\n        resolve({ proof, useEthKey: this.useEthKey, status: true });\n      })\n    })\n  }\n\n\n  async _authenticate(unsignedToken, unEndPoint, signCallback) {\n    console.log('authenticate request. need to implement UN request/sign');\n    let useEthKey;\n    try {\n      useEthKey = await this.getChallengeSigned();\n    } catch (e) {\n      signCallback(null, e);\n      return;\n    }\n\n    console.log(\"useEthKey\", useEthKey);\n\n    this.useEthKey = useEthKey;\n\n    this.signCallback = signCallback;\n    // open iframe and request tokens\n    this.queuedCommand = { parentCommand: 'signToken', parentData: unsignedToken };\n    this.createIframe();\n  }\n\n  getInt64Bytes(x) {\n    var bytes = [];\n    var i = 8;\n    do {\n      bytes[--i] = x & (255);\n      x = x >> 8;\n    } while (i)\n    return bytes;\n  }\n\n  async getUnpredictableNumber(endPoint) {\n    // TODO implement endpoint request\n\n    const expiry = Date.now() + this.UNttl * 1000;\n    let random = Math.floor(Math.random() * (10 ** this.maxUNlength));\n\n    return {\n      UN: random.toString() + this.createHmac(random, expiry),\n      Expiry: expiry\n    }\n  }\n\n  createHmac(random, expiry) {\n    let randomAndExpiryAsBytes = this.getInt64Bytes(random).concat(this.getInt64Bytes(expiry));\n    return ethers.utils.computeHmac(\"sha256\", this.UNsecret, randomAndExpiryAsBytes);\n  }\n\n  ethKeyIsValid(ethKey) {\n    let random = parseInt(ethKey.UN.substr(0, ethKey.UN.length - 66));\n    let hmac = this.createHmac(random, ethKey.expiry);\n    if (hmac !== ethKey.UN.substr(ethKey.UN.length - 66)) return false;\n    if (ethKey.expiry < Date.now()) return false;\n    return true;\n  }\n\n  async getChallengeSigned(unEndPoint) {\n\n    const storageEthKeys = localStorage.getItem(this.localStorageEthKeyItemName);\n    let ethKeys;\n\n    if (storageEthKeys && storageEthKeys.length) {\n      ethKeys = JSON.parse(storageEthKeys);\n    } else {\n      ethKeys = {};\n    }\n\n    let address = await this.connectMetamaskAndGetAddress();\n    address = address.toLowerCase();\n\n    let useEthKey;\n\n    if (ethKeys && ethKeys[address] && !this.ethKeyIsValid(ethKeys[address])) {\n      console.log('remove invalid useEthKey');\n      delete ethKeys[address];\n    }\n\n    if (ethKeys && ethKeys[address]) {\n      useEthKey = ethKeys[address];\n    } else {\n      useEthKey = await this.signNewChallenge(unEndPoint);\n      if (useEthKey) {\n        ethKeys[useEthKey.address.toLowerCase()] = useEthKey;\n        localStorage.setItem(this.localStorageEthKeyItemName, JSON.stringify(ethKeys));\n      }\n    }\n    return useEthKey;\n  }\n\n  async signNewChallenge(unEndPoint) {\n    const { UN, Expiry } = await this.getUnpredictableNumber(unEndPoint);\n\n    const domain = window.location.hostname;\n\n    const challenge = `This is proof that I am visiting ${domain}, which has presented the following challenge ${UN.toString()} to sign.`;\n\n    let signature = await this.signMessageWithBrowserWallet(challenge);\n    const msgHash = ethers.utils.hashMessage(challenge);\n    const msgHashBytes = ethers.utils.arrayify(msgHash);\n\n    const recoveredAddress = ethers.utils.recoverAddress(msgHashBytes, signature);\n\n    return {\n      address: recoveredAddress,\n      expiry: Expiry,\n      challenge,\n      signature,\n      UN\n    };\n  }\n\n  negotiate() {\n    return new Promise((resolve, reject) => {\n      this._negotiate((tokens) => {\n        if (!tokens) return reject(false)\n        resolve(tokens);\n      })\n    })\n  }\n  \n  getTokenInstances() {\n    return new Promise((resolve, reject) => {\n      this._negotiate((tokens) => {\n        if (!tokens) return reject(false)\n        resolve(tokens);\n      })\n    })\n  }\n\n  _negotiate(callBack) {\n\n    if (this.userPermissionStatus === false) {\n      return false;\n    }\n    this.negotiateCallback = callBack;\n\n    if (this.attestationOrigin) {\n\n      console.log('attestationOrigin', this.attestationOrigin);\n\n      if (window.location.href === this.tokensOrigin) {\n        // just read an return tokens\n        let tokensOutput = this.readTokens();\n        if (tokensOutput.success && !tokensOutput.noTokens) {\n          let decodedTokens = this.decodeTokens(tokensOutput.tokens);\n          let filteredTokens = this.filterTokens(decodedTokens);\n          tokensOutput.tokens = filteredTokens;\n          this.negotiateCallback(tokensOutput);\n        }\n      } else {\n        this.queuedCommand = { parentCommand: 'tokensList', parentData: '' };\n        this.createIframe()\n      }\n    } else {\n      console.log('no attestationOrigin...');\n      // TODO test token against blockchain and show tokens as usual view\n    }\n  }\n\n  createIframe() {\n    console.log('createIframe fired');\n    // open iframe and request tokens\n    this.attachPostMessageListener(this.listenForIframeMessages.bind(this));\n\n    const iframe = document.createElement('iframe');\n    this.iframe = iframe;\n    iframe.src = this.tokensOrigin;\n    iframe.style.width = '800px';\n    iframe.style.height = '700px';\n    iframe.style.maxWidth = '100%';\n    iframe.style.background = '#fff';\n    let iframeWrap = document.createElement('div');\n    this.tokenIframeWrap = iframeWrap;\n    iframeWrap.setAttribute('style', 'width:100%; min-height: 100vh; position: fixed; align-items: center; justify-content: center; display: none; top: 0; left: 0; background: #fffa');\n    iframeWrap.appendChild(iframe);\n    document.body.appendChild(iframeWrap);\n  }\n\n  base64ToUint8array(base64str) {\n    // decode base64url to base64. it will do nothing for base64\n    base64str = base64str.split('-').join('+')\n      .split('_').join('/')\n      .split('.').join('=');\n    let res;\n\n    if (typeof Buffer !== 'undefined') {\n      res = Uint8Array.from(Buffer.from(base64str, 'base64'));\n    } else {\n      res = Uint8Array.from(atob(base64str), c => c.charCodeAt(0));\n    }\n    return res;\n  }\n\n  decodeTokens(rawTokens) {\n    if (this.debug) {\n      console.log('decodeTokens fired');\n      console.log(rawTokens);\n    }\n    let decodedTokens = [];\n    if (rawTokens.length) {\n      rawTokens.forEach(tokenData => {\n        if (tokenData.token) {\n          let decodedToken = new this.tokenParser(this.base64ToUint8array(tokenData.token).buffer);\n          if (decodedToken && decodedToken[this.unsignedTokenDataName]) decodedTokens.push(decodedToken[this.unsignedTokenDataName]);\n        } else {\n          console.log('empty token data received');\n        }\n\n      })\n    }\n    return decodedTokens;\n  }\n\n  attachPostMessageListener(listener) {\n    if (window.addEventListener) {\n      window.addEventListener(\"message\", listener, false);\n    } else {\n      // IE8\n      window.attachEvent(\"onmessage\", listener);\n    }\n  }\n  detachPostMessageListener(listener) {\n    if (window.addEventListener) {\n      window.removeEventListener(\"message\", listener, false);\n    } else {\n      // IE8\n      window.detachEvent(\"onmessage\", listener);\n    }\n  }\n}","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER, Utf8String\n} from \"asn1js\";\nimport { getParametersValue, clearProps, bufferToHexCodes } from \"pvutils\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\nimport PublicKeyInfo from \"./PublicKeyInfo.js\";\n\nexport class DevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is CER encoded\n   */\n  constructor(source = {}) {\n    if (typeof (source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      this.devconId = getParametersValue(\n          source,\n          \"devconId\"\n      );\n      this.ticketId = getParametersValue(\n          source,\n          \"ticketId\"\n      );\n      this.ticketClass = getParametersValue(\n          source,\n          \"ticketClass\"\n      );\n    }\n  }\n\n  static schema(parameters = {}) {\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"ticket\",\n      value: [\n        new Utf8String({\n          name: names.devconId || \"devconId\",\n        }),\n        new Integer({\n          name: names.ticketId || \"ticketId\",\n        }),\n        new Integer({\n          name: names.ticketClass || \"ticketClass\",\n        }),\n      ],\n    });\n  }\n\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"devconId\",\n      \"ticketId\",\n      \"ticketClass\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, DevconTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\"Object's schema was not verified against input data for DevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    if (\"devconId\" in asn1.result) {\n      this.devconId = asn1.result[\"devconId\"].valueBlock.value;\n    }\n\n    if (\"ticketId\" in asn1.result) {\n      const ticketId = asn1.result[\"ticketId\"].valueBlock._valueHex;\n      this.ticketId = BigInt(\"0x\" + bufferToHexCodes(ticketId));\n    }\n\n    if (\"ticketClass\" in asn1.result) {\n      const ticketClass = asn1.result[\"ticketClass\"].valueBlock._valueHex;\n      this.ticketClass = BigInt(\"0x\" + bufferToHexCodes(ticketClass));\n    }\n\n    //endregion\n  }\n}\n\nexport class SignedDevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is DER encoded\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n\n      const ticketEncoded = (source.startsWith(\"https://\")) ?\n          (new URL(source)).searchParams.get('ticket') : source;\n      \n      let base64str = ticketEncoded\n          .split('_').join('/')\n          .split('-').join('+')\n          .split('.').join('=');\n\n      // source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      if (typeof Buffer !== 'undefined') {\n        source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      } else {\n        source = Uint8Array.from(atob(base64str), c => c.charCodeAt(0)).buffer;\n      }\n      \n    }\n\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source);\n      this.fromSchema(asn1.result);\n    } else {\n      this.ticket = new DevconTicket(source.ticket);\n\n      this.commitment = getParametersValue(\n          source,\n          \"commitment\"\n      );\n\n      // TODO: issue #75\n      // this.signatureAlgorithm = new AlgorithmIdentifier(source.signatureAlgorithm);\n\t  \n\t  this.publicKeyInfo = new PublicKeyInfo(source.publicKeyInfo)\n\n      this.signatureValue = getParametersValue(\n          source,\n          \"signatureValue\"\n      );\n    }\n  }\n\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * CertificateList  ::=  SEQUENCE  {\n   *    tbsCertList          TBSCertList,\n   *    signatureAlgorithm   AlgorithmIdentifier,\n   *    signatureValue       BIT STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} [blockName]\n     * @property {string} [signatureAlgorithm]\n     * @property {string} [signatureValue]\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"SignedDevconTicket\",\n      value: [\n        DevconTicket.schema(parameters),\n        new OctetString({\n          name: \"commitment\",\n        }),\n        /* PublicKeyInfo is specified in schema here but not appearing in the constructed data object.\n         * This is because the underlying AlgorithmIdentifier isn't fully implemented and also\n         * that this data is not important for the 1st delivery deadline, won't be read by client anyway.\n         * TODO: add support for PublicKeyInfo https://github.com/TokenScript/attestation/issues/75\n         */\n        // new Sequence( {\n        //   name: \"publicKeyInfo\",\n        //   optional: true,\n        //   value: [\n        //     PublicKeyInfo.schema(\n        //         names.publicKeyInfo || {\n        //           names: {\n        //             blockName: \"publicKeyInfo\",\n        //           },\n        //         }\n        //     )\n        //   ]\n        // }),\n\n        new BitString({\n          name: \"signatureValue\",\n        }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"ticket\",\n      \"commitment\",\n      // TODO: #75\n\t  \"publicKeyInfo\",\n      \"signatureValue\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, SignedDevconTicket.schema());\n\n    if (asn1.verified === false)\n\t\tthrow new Error(\"Object's schema was not verified against input data for SignedDevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    this.ticket = new DevconTicket(asn1.result.ticket.valueBeforeDecode)\n\n    if (\"commitment\" in asn1.result)\n      this.commitment = asn1.result[\"commitment\"].valueBlock.valueHex;\n\n    // TODO: issue #75\n    // this.signatureAlgorithm = new AlgorithmIdentifier(asn1.result.signatureAlgorithm);\n\tthis.publicKeyInfo = new PublicKeyInfo({\n      schema: asn1.result.publicKeyInfo,\n    });\n\n    const signatureValue = asn1.result.signatureValue;\n    this.signatureValue = signatureValue.valueBlock.valueHex;    //endregion\n  }\n}","import React from 'react';\nimport Typography from '@material-ui/core/Typography';\nimport './Card.css';\n\nfunction MediaCard({ tokenInstance }) {\n\n  // New Data Structure:\n  const { ticketClass, ticketId, devconId } = tokenInstance;\n  return (\n    <div className=\"ticketContainer\">\n      <div className=\"ticketDetails\">\n        <Typography className=\"ticketClass\" variant=\"h5\" component=\"h2\">\n          {ticketClass.toString()}\n        </Typography>\n        <Typography className=\"ticketId\" variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          {ticketId && ticketId.toString()}\n        </Typography>\n        <Typography className=\"devconId\" variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          Devcon ID: {devconId && devconId.toString()}\n        </Typography>\n      </div>\n      <img className=\"ticketImg\" src=\"ticket_example_image.svg\"></img>\n    </div>\n  );\n}\n\nexport default MediaCard;\n","import React, { useState, useEffect } from 'react';\n// import { Negotiator } from 'token-negotiator';\nimport { Negotiator } from './temp/negotiator';\nimport Card from './Card';\nimport './App.css';\n\n// A minimal example to read tokens and render them to a view.\n\nconst mockTicketData = [\n  {\n    ticket: \"MIGWMA0MATYCBWE3ap3-AgEABEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNCAOOZKRpcE6tLBuPbfE_SmwPk2wNjbj5vpa6kkD7eqQXvBOCa0WNo8dEHKvipeUGZZEWWjJKxooB44dEYdQO70Vgc\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n  {\n    ticket: \"MIGXMA4MAjExAgVhN2qd_gIBAARBBCiWVcTBF25EmWQVpzVE1_-YnrvBlKn9G8f2tLQTxekGLJAAWjCQWIQzl7JkLd3LJP03zGdsHZn0ZCu3jwjiNpIDQgBbJBY1Ctlp_czUwB85yF1e5kpZ-lQ_-UZ7jaCYSFoEx028Jit1HIDLCJezKdsNn9c9IO7-HC-_r2ZLaYQ9GGrbHA==\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n  {\n    ticket: \"MIGTMAoMATYCAgDeAgEABEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNCAEZYXbNmWXDsAqIc5uf7SirR-dLCMLdEVN5teFrV93VbcKE_DED8c6jtFQ5LH2SRXwPEtXZqWfEh1c2OHTEYqfwb\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n  {\n    ticket: \"MIGSMAkMATECAQECAQAEQQQollXEwRduRJlkFac1RNf_mJ67wZSp_RvH9rS0E8XpBiyQAFowkFiEM5eyZC3dyyT9N8xnbB2Z9GQrt48I4jaSA0IAOf4d0N9shWfPIgRXZPdBRhlRyIARDT0tJwNWYwy2ILVKnIy-qPzFsgdI6sZHm1OY6UsJKuDlp0A7EMC8vS5YhRs=\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n];\n\nfunction App() {\n\n  if(document.hasStorageAccess) {\n    document.hasStorageAccess().then((hasAccess) => {\n      console.log(\"user access: \", hasAccess);\n      if (!hasAccess) {\n        document.requestStorageAccess().then(hasAccessFromRequest => {\n          console.log(\"user access from request: \", hasAccessFromRequest);\n        });\n      }\n    });\n  }\n\n  // local State: tokens[], setTokens: Method to update the state of tokens.\n  let [tokens, setTokens] = useState([]);\n  // create instance of Negotiator.\n  const filter = {};\n  const token = \"devcon-ticket\";\n  const options = {};\n  const negotiator = new Negotiator(filter, token, options);\n  //\n  useEffect(async () => {\n    // on success assign tokens to react state\n    const devconData = await negotiator.negotiate();\n    if(devconData.success) setTokens(devconData.tokens);\n  }, []);\n\n  // This is one example of how the ticket can be loaded inside a new tab\n  // when navigating back to this page you will find the ticket in view.\n  // Alternative ways include; navigation to the ticket store page, which redirects\n  // back to this page once complete.\n  const openTicketInNewTab = async ({event, ticket, secret, id}) => {\n    event.preventDefault();\n    const magicLink = `https://devcontickets.herokuapp.com/outlet/?ticket=${ticket}&secret=${secret}&id=${id}`;\n    negotiator.addTokenThroughIframe(magicLink); \n    // For this demo - where tickets are loaded from within the page a timeout is used to allow time for the token to be negotiated\n    // and loaded into the view. \n    // In a scenario where the ticket is embeded within a URL, when the end user navigates to the link, links could be provided in this\n    // page to direct the user e.g. to Devcon or third parties who accept the token. \n    negotiator.negotiate().then(res => {\n      if(res.success) setTokens(res.tokens);\n    });\n  }\n\n  return (\n    <main>\n      <a href=\"/\"><img className=\"logo\" src=\"./devcon.svg\"></img></a>\n      <div className=\"flexCenter\">\n        <p>[DEMO Ticket Issuer Website]</p>\n      </div>\n      <div className=\"flexCenter\">\n        <img className=\"devcon_bogota\" src=\"./devcon_bogota.svg\"></img>\n      </div>\n      <div className=\"flexCenter\">\n        <p>A Devcon ticket provides access to the event and special offers between the dates X-XX for hotel bookings, travel, restaurants and more.</p>\n      </div>\n      <div className=\"flexCenter\">\n        <p>Your tickets:</p>\n      </div>\n      <div className=\"flexCenter\">\n        <div className=\"tokensWrapper\">\n          {\n            tokens && tokens.length > 0 && tokens.map((tokenInstance, index) => {\n              return <Card key={index} tokenInstance={tokenInstance} />\n            })\n          }\n          {\n            !tokens.length && <div>\n              <b>- no ticket found -</b>\n              <p>Generate ticket:</p>\n              <div className=\"ticketWrapper\">\n                {\n                  mockTicketData.map((mockTicket, index) => {\n                    return (\n                      <button key={index} className=\"makeTicket\" onClick={event => openTicketInNewTab({ \n                        event,\n                        ticket: mockTicket.ticket,\n                        secret: mockTicket.secret,\n                        id: mockTicket.id\n                      })}>Create Ticket</button> \n                    )\n                  })\n                }\n              </div>\n            </div>\n          }\n        </div>\n      </div>\n    </main>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}