{"version":3,"sources":["temp/Attestation/AlgorithmIdentifier.js","temp/Attestation/PublicKeyInfo.js","temp/negotiator/index.js","temp/Attestation/SignedDevonTicket.js","Card/index.js","App.js","reportWebVitals.js","index.js"],"names":["AlgorithmIdentifier","source","TypeError","ArrayBuffer","asn1","fromBER","this","fromSchema","result","algorithmId","getParametersValue","algorithmParams","defaultValues","schema","clearProps","compareSchema","names","algorithmIdentifier","verified","Error","algorithm","valueBlock","toString","params","outputArray","push","ObjectIdentifier","value","asn1js","Any","Sequence","object","toJSON","JSON","stringify","memberName","memberValue","parameters","name","blockName","optional","PublicKeyInfo","signatureAlgorithm","publicKey","BitString","Negotiator","filter","options","attestationOrigin","console","log","tokenOrigin","XMLconfig","tokenUrlName","tokenSecretName","unsignedTokenDataName","tokenParserUrl","tokenParser","SignedDevconTicket","localStorageItemName","queuedCommand","debug","hideTokensIframe","hasOwnProperty","isTokenOriginWebsite","currentURL","URL","window","location","href","tokenOriginURL","origin","readMagicUrl","parent","attachPostMessageListener","listenForParentMessages","bind","referrer","document","postMessage","iframeCommand","iframeData","event","data","parentCommand","parentData","command","Authenticator","rawTokenData","getRawToken","base64ticket","token","ticketSecret","secret","authenticator","getAuthenticationBlob","ticketBlob","res","useToken","message","success","returnTokensToParent","tokensOutput","readTokens","noTokens","decodedTokens","decodeTokens","tokens","filteredTokens","filterTokens","urlParams","URLSearchParams","search","tokenFromQuery","get","secretFromQuery","isNewQueryTicket","map","tokenData","localStorage","setItem","Object","keys","length","filterKeys","forEach","fitFilter","key","o1","o2","p","storageTickets","getItem","output","parse","item","e","callBack","unsignedToken","rawTokens","decodedToken","base64ToUint8array","buffer","decodedTokenData","compareObjects","tokenIframeWrap","style","display","detachPostMessageListener","listenForIframeMessages","remove","negotiateCallback","signCallback","createIframe","iframe","createElement","src","width","height","maxWidth","background","iframeWrap","setAttribute","appendChild","body","base64str","split","join","Buffer","Uint8Array","from","atob","c","charCodeAt","listener","addEventListener","attachEvent","removeEventListener","detachEvent","DevconTicket","devconId","ticketId","ticketClass","_valueHex","BigInt","bufferToHexCodes","Integer","ticketEncoded","startsWith","searchParams","ticket","commitment","publicKeyInfo","signatureValue","valueBeforeDecode","valueHex","OctetString","MediaCard","tokenInstance","className","Typography","gutterBottom","variant","component","color","App","useState","setTokens","negotiator","useEffect","getTokenInstances","index","target","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b58d006c.chunk.js","sourcesContent":["import { Any, compareSchema, ObjectIdentifier, Sequence } from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class AlgorithmIdentifier {\n  //**********************************************************************************\n  /**\n   * Constructor for AlgorithmIdentifier class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.algorithmId = getParametersValue(\n          source,\n          \"algorithmId\"\n      );\n\n      if (\"algorithmParams\" in source)\n        /**\n         * @type {Object}\n         * @desc Any algorithm source\n         */\n        this.algorithmParams = getParametersValue(\n            source,\n            \"algorithmParams\",\n            AlgorithmIdentifier.defaultValues(\"algorithmParams\")\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n   /* FIXME: algorithmParams is options hence not removed and we need to complete this with all parameters with their default value covered here.\n   */\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithmParams\":\n        return new Any();\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return memberValue === \"\";\n      case \"algorithmParams\":\n        return memberValue instanceof asn1js.Any;\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * AlgorithmIdentifier  ::=  Sequence  {\n   *    algorithm               OBJECT IDENTIFIER,\n   *    parameters              ANY DEFINED BY algorithm OPTIONAL  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\n     * @property {string} algorithmParams Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || false,\n      value: [\n        new ObjectIdentifier({ name: names.algorithmIdentifier || \"algorithm\" }),\n        new Any({ name: names.algorithmParams || \"parameters\", optional: true }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"algorithm\", \"params\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      AlgorithmIdentifier.schema({\n        names: {\n          algorithmIdentifier: \"algorithm\",\n          algorithmParams: \"params\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n\n    //region Get internal properties from parsed schema\n    this.algorithmId = asn1.result.algorithm.valueBlock.toString();\n    if (\"params\" in asn1.result) this.algorithmParams = asn1.result.params;\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    outputArray.push(new ObjectIdentifier({ value: this.algorithmId }));\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      outputArray.push(this.algorithmParams);\n    //endregion\n\n    //region Construct and return new ASN.1 schema for this object\n    return new Sequence({\n      value: outputArray,\n    });\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n  toJSON() {\n    const object = {\n      algorithmId: this.algorithmId,\n    };\n\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      object.algorithmParams = this.algorithmParams.toJSON();\n\n    return object;\n  }\n  //**********************************************************************************\n  /**\n   * Check that two \"AlgorithmIdentifiers\" are equal\n   * @param {AlgorithmIdentifier} algorithmIdentifier\n   * @returns {boolean}\n   */\n  isEqual(algorithmIdentifier) {\n    //region Check input type\n    if (algorithmIdentifier instanceof AlgorithmIdentifier === false)\n      return false;\n    //endregion\n\n    //region Check \"algorithm_id\"\n    if (this.algorithmId !== algorithmIdentifier.algorithmId) return false;\n    //endregion\n\n    //region Check \"algorithm_params\"\n    if (\"algorithmParams\" in this) {\n      if (\"algorithmParams\" in algorithmIdentifier)\n        return (\n          JSON.stringify(this.algorithmParams) ===\n          JSON.stringify(algorithmIdentifier.algorithmParams)\n        );\n\n      return false;\n    }\n\n    if (\"algorithmParams\" in algorithmIdentifier) return false;\n    //endregion\n\n    return true;\n  }\n  //**********************************************************************************\n}\n//**************************************************************************************\n","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER,\n  Any,\n  ObjectIdentifier\n} from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class PublicKeyInfo {\n  //**********************************************************************************\n  /**\n   * Constructor for PublicKeyInfo class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Not accepting string. For base64, convert to ArrayBuffer.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.signatureAlgorithm = getParametersValue(\n          source,\n          \"signatureAlgorithm\"\n      );\n\t  this.publicKey = getParametersValue(\n          source,\n          \"publicKey\"\n      );\n    }\n  }\n \n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * PublicKeyInfo  ::=  Sequence  {\n   *    signatureAlgorithm               AlgorithmIdentifier,\n   *    publicKey              BIT-STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} signatureAlgorithm ObjectIdentifier for the algorithm\n     * @property {string} publicKey Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: true,\n      value: [\n\t\tAlgorithmIdentifier.schema(\n\t\t\tnames.signatureAlgorithm || {\n\t\t\t  names: {\n\t\t\t\tblockName: \"signatureAlgorithm\",\n\t\t\t  },\n\t\t\t}\n\t\t),\n        new BitString({ name: \"publicKey\"}),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"signatureAlgorithm\", \"publicKey\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      PublicKeyInfo.schema({\n        names: {\n          signatureAlgorithm: \"signatureAlgorithm\",\n          publicKey: \"publicKey\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n  }\n}\n//**************************************************************************************\n","import { SignedDevconTicket } from './../Attestation/SignedDevonTicket';\n\nexport class Negotiator {\n  constructor(filter = {}, options = {}) {\n\n    // soft developer warnings:\n    if (!options.attestationOrigin) console.log('no attestation origin provided');\n    if (!options.tokenOrigin) console.log('no tokenOrigin provided');\n\n    let XMLconfig = {\n      attestationOrigin: options.attestationOrigin,\n      tokenOrigin: options.tokenOrigin,\n      tokenUrlName: 'ticket',\n      tokenSecretName: 'secret',\n      unsignedTokenDataName: 'ticket',\n      tokenParserUrl: '',\n      tokenParser: SignedDevconTicket,\n      localStorageItemName: 'dcTokens'\n    };\n\n    this.queuedCommand = false;\n    this.filter = filter;\n    this.debug = 0;\n    this.hideTokensIframe = 1;\n    this.tokenOrigin = XMLconfig.tokenOrigin;\n    this.attestationOrigin = XMLconfig.attestationOrigin;\n    this.tokenUrlName = XMLconfig.tokenUrlName;\n    this.tokenSecretName = XMLconfig.tokenSecretName;\n    this.unsignedTokenDataName = XMLconfig.unsignedTokenDataName;\n    this.tokenParser = XMLconfig.tokenParser;\n    this.localStorageItemName = XMLconfig.localStorageItemName;\n    if (options.hasOwnProperty('debug')) this.debug = options.debug;\n    if (options.hasOwnProperty('attestationOrigin')) this.attestationOrigin = options.attestationOrigin;\n    if (options.hasOwnProperty('tokenOrigin')) this.tokenOrigin = options.tokenOrigin;\n    this.isTokenOriginWebsite = false;\n    if (this.attestationOrigin) {\n      // if attestationOrigin filled then token need attestaion\n      let currentURL = new URL(window.location.href);\n      let tokenOriginURL = new URL(this.tokenOrigin);\n      if (currentURL.origin === tokenOriginURL.origin) {\n        console.log('this is tokenOrigin. fire listener and read params');\n        // its tokens website, where tokens saved in localStorage\n        // lets check url params and save token data to the local storage\n        this.isTokenOriginWebsite = true;\n        this.readMagicUrl();\n      }\n    }\n\n    // do we inside iframe?\n    if (window !== window.parent) {\n      this.debug && console.log('negotiator: its iframe, lets return tokens to the parent');\n      // its iframe, listen for requests\n      this.attachPostMessageListener(this.listenForParentMessages.bind(this))\n      // send ready message to start interaction\n      let referrer = new URL(document.referrer);\n      window.parent.postMessage({ iframeCommand: \"iframeReady\", iframeData: '' }, referrer.origin);\n    }\n  }\n\n  listenForParentMessages(event) {\n    // listen only parent\n    let referrer = new URL(document.referrer);\n    if (event.origin !== referrer.origin) return;\n    // console.log('iframe: event = ', event.data);\n    // parentCommand+parentData required for interaction\n    if (\n      typeof event.data.parentCommand === \"undefined\"\n      || typeof event.data.parentData === \"undefined\"\n    ) {\n      return;\n    }\n    // parentCommand contain command code\n    let command = event.data.parentCommand;\n    // parentData contains command content (token to sign or empty object)\n    let data = event.data.parentData;\n    console.log('iframe: command, data = ', command, data);\n    switch (command) {\n      case \"signToken\":\n        console.log('let Auth data:', data);\n        if (typeof window.Authenticator === \"undefined\") {\n          console.log('Authenticator not defined.');\n          return;\n        }\n        let rawTokenData = this.getRawToken(data);\n        // console.log('rawTokenData: ',rawTokenData);\n        let base64ticket = rawTokenData.token;\n        let ticketSecret = rawTokenData.secret;\n        this.authenticator = new Authenticator(this);\n        this.authenticator.getAuthenticationBlob({\n          ticketBlob: base64ticket,\n          ticketSecret: ticketSecret,\n          attestationOrigin: this.attestationOrigin,\n        },\n          res => {\n            console.log('sign result:', res);\n            window.parent.postMessage({ iframeCommand: \"useTokenData\", iframeData: { useToken: res, message: '', success: !!res } }, referrer.origin);\n          });\n        break;\n      case \"tokensList\":\n        // TODO update - (confirm if there is an action to take)\n        console.log('let return tokens');\n        this.returnTokensToParent();\n        break;\n      default:\n    }\n  }\n\n  commandDisplayIframe() {\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"iframeWrap\", iframeData: 'show' }, referrer.origin);\n  }\n\n  commandHideIframe() {\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"iframeWrap\", iframeData: 'hide' }, referrer.origin);\n  }\n\n  returnTokensToParent() {\n    let tokensOutput = this.readTokens();\n    if (tokensOutput.success && !tokensOutput.noTokens) {\n      let decodedTokens = this.decodeTokens(tokensOutput.tokens);\n      let filteredTokens = this.filterTokens(decodedTokens);\n      tokensOutput.tokens = filteredTokens;\n    }\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"tokensData\", iframeData: tokensOutput }, referrer.origin);\n  }\n\n  readMagicUrl() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const tokenFromQuery = urlParams.get(this.tokenUrlName);\n    const secretFromQuery = urlParams.get(this.tokenSecretName);\n    if (!(tokenFromQuery && secretFromQuery)) return;\n    // Get the current Storage Tokens\n    let tokensOutput = this.readTokens();\n    let tokens = [];\n    let isNewQueryTicket = true;\n    if (!tokensOutput.noTokens) {\n      // Build new list of tickets from current and query ticket { ticket, secret }\n      tokens = tokensOutput.tokens;\n      tokens.map(tokenData => {\n        if (tokenData.token === tokenFromQuery) {\n          isNewQueryTicket = false;\n        }\n      });\n    }\n    // Add ticket if new\n    // if (isNewQueryTicket && tokenFromQuery && secretFromQuery) {\n    if (isNewQueryTicket) {\n      tokens.push({ token: tokenFromQuery, secret: secretFromQuery }); // new raw object\n    }\n    // Set New tokens list raw only, websters will be decoded each time\n    localStorage.setItem(this.localStorageItemName, JSON.stringify(tokens));\n  }\n\n  /*\n   * Return token objects satisfying the current negotiator's requirements\n   */\n  filterTokens(decodedTokens, filter = {}) {\n    if (Object.keys(filter).length == 0) {\n      filter = this.filter;\n    }\n    let res = [];\n    if (\n      decodedTokens.length\n      && typeof filter === \"object\"\n      && Object.keys(filter).length\n    ) {\n      let filterKeys = Object.keys(filter);\n      decodedTokens.forEach(token => {\n        let fitFilter = 1;\n        this.debug && console.log('test token:', token);\n        filterKeys.forEach(key => {\n          if (token[key].toString() != filter[key].toString()) fitFilter = 0;\n        })\n        if (fitFilter) {\n          res.push(token);\n          this.debug && console.log('token fits:', token);\n        }\n      })\n      return res;\n    } else {\n      return decodedTokens;\n    }\n  }\n\n  compareObjects(o1, o2) {\n    for (var p in o1) {\n      if (o1.hasOwnProperty(p)) {\n        if (o1[p].toString() !== o2[p].toString()) {\n          return false;\n        }\n      }\n    }\n    for (var p in o2) {\n      if (o2.hasOwnProperty(p)) {\n        if (o1[p].toString() !== o2[p].toString()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // read tokens from local storage and return as object {tokens: [], noTokens: boolean, success: boolean}\n  readTokens() {\n    const storageTickets = localStorage.getItem(this.localStorageItemName);\n    let tokens = [];\n    let output = { tokens: [], noTokens: true, success: true };\n    try {\n      if (storageTickets && storageTickets.length) {\n        // Build new list of tickets from current and query ticket { ticket, secret }\n        tokens = JSON.parse(storageTickets);\n        if (tokens.length !== 0) {\n          // output.tokens = tokens;\n          tokens.forEach(item => {\n            if (item.token && item.secret) {\n              output.tokens.push({\n                token: item.token,\n                secret: item.secret\n              })\n            }\n          })\n        }\n        if (output.tokens.length) {\n          output.noTokens = false;\n        }\n      }\n    } catch (e) {\n      console.log('Cant parse tokens in LocalStorage');\n      if (typeof callBack === \"function\") {\n        output.success = false;\n      }\n    }\n    return output;\n  }\n\n  getRawToken(unsignedToken) {\n    let tokensOutput = this.readTokens();\n    if (tokensOutput.success && !tokensOutput.noTokens) {\n      let rawTokens = tokensOutput.tokens;\n      let token = false;\n      if (rawTokens.length) {\n        rawTokens.forEach(tokenData => {\n          if (tokenData.token) {\n            let decodedToken = new this.tokenParser(this.base64ToUint8array(tokenData.token).buffer);\n            if (decodedToken && decodedToken[this.unsignedTokenDataName]) {\n              let decodedTokenData = decodedToken[this.unsignedTokenDataName];\n              if (this.compareObjects(decodedTokenData, unsignedToken)) {\n                token = tokenData;\n              }\n            }\n          } else {\n            console.log('empty token data received');\n          }\n        })\n      }\n      return token;\n    }\n  }\n\n  listenForIframeMessages(event) {\n    let tokenOriginURL = new URL(this.tokenOrigin);\n    // listen only tokenOriginURL\n    if (event.origin !== tokenOriginURL.origin) {\n      return;\n    }\n    // console.log('parent: event = ', event.data);\n    // iframeCommand required for interaction\n    if (\n      typeof event.data.iframeCommand === \"undefined\"\n      || typeof event.data.iframeData === \"undefined\"\n    ) {\n      return;\n    }\n    // iframeCommand contain command code\n    let command = event.data.iframeCommand;\n    // iframeData contains command content (tokens data, useToken , hide/display iframe)\n    let data = event.data.iframeData;\n    console.log('parent: command, data = ', command, data);\n    switch (command) {\n      case \"iframeWrap\":\n        if (data == \"show\") {\n          this.tokenIframeWrap.style.display = 'block';\n        } else if (data == \"hide\") {\n          this.tokenIframeWrap.style.display = 'none';\n        }\n        break;\n      case \"tokensData\":\n        // tokens received, disable listener\n        this.detachPostMessageListener(this.listenForIframeMessages);\n        // TODO remove iframeWraper\n        this.tokenIframeWrap.remove();\n        if (data.success && !data.noTokens) {\n          data.tokens = this.filterTokens(data.tokens);\n        }\n        this.negotiateCallback(data);\n        break;\n      case \"useTokenData\":\n        this.tokenIframeWrap.remove();\n        // if (data.success) {\n        //     console.log('useTokenData: ' + data.useToken)\n        // } else {\n        //     console.log('useTokenData error message: ' + data.message)\n        // }\n        console.log('this.signCallback(data)');\n        this.signCallback && this.signCallback(data);\n        this.signCallback = false;\n        break;\n      case \"iframeReady\":\n        event.source.postMessage(this.queuedCommand, event.origin);\n        this.queuedCommand = '';\n        break;\n      default:\n    }\n  }\n\n  signToken(unsignedToken, signCallback) {\n    this.signCallback = signCallback;\n    // open iframe and request tokens\n    this.queuedCommand = { parentCommand: 'signToken', parentData: unsignedToken };\n    this.createIframe();\n  }\n\n  getTokenInstances(callBack) {\n    // callback function required\n    if (typeof callBack !== \"function\") {\n      return false;\n    }\n    console.log('negotiateCallback added;');\n    this.negotiateCallback = callBack;\n    console.log('attestationOrigin = ' + this.attestationOrigin);\n    if (this.attestationOrigin) {\n      if (window.location.href === this.tokenOrigin) {\n        // just read an return tokens\n        let tokensOutput = this.readTokens();\n        if (tokensOutput.success && !tokensOutput.noTokens) {\n          let decodedTokens = this.decodeTokens(tokensOutput.tokens);\n          let filteredTokens = this.filterTokens(decodedTokens);\n          tokensOutput.tokens = filteredTokens;\n          this.negotiateCallback(tokensOutput);\n        }\n      } else {\n        this.queuedCommand = { parentCommand: 'tokensList', parentData: '' };\n        this.createIframe()\n      }\n    } else {\n      console.log('no attestationOrigin');\n      // TODO test token against blockchain and show tokens as usual view\n      this.negotiateCallback([]);\n    }\n  }\n\n  createIframe() {\n    console.log('open iframe');\n    // open iframe and request tokens\n    this.attachPostMessageListener(this.listenForIframeMessages.bind(this));\n    const iframe = document.createElement('iframe');\n    this.iframe = iframe;\n    iframe.src = this.tokenOrigin;\n    iframe.style.width = '800px';\n    iframe.style.height = '700px';\n    iframe.style.maxWidth = '100%';\n    iframe.style.background = '#fff';\n    let iframeWrap = document.createElement('div');\n    this.tokenIframeWrap = iframeWrap;\n    iframeWrap.setAttribute('style', 'width:100%; min-height: 100vh; position: fixed; align-items: center; justify-content: center; display: none; top: 0; left: 0; background: #fffa');\n    iframeWrap.appendChild(iframe);\n    document.body.appendChild(iframeWrap);\n  }\n\n  base64ToUint8array(base64str) {\n    // decode base64url to base64. it will do nothing for base64\n    base64str = base64str.split('-').join('+')\n      .split('_').join('/')\n      .split('.').join('=');\n    let res;\n    if (typeof Buffer !== 'undefined') {\n      res = Uint8Array.from(Buffer.from(base64str, 'base64'));\n    } else {\n      res = Uint8Array.from(atob(base64str), c => c.charCodeAt(0));\n    }\n    return res;\n  }\n\n  decodeTokens(rawTokens) {\n    if (this.debug) {\n      console.log('decodeTokens fired');\n      console.log(rawTokens);\n    }\n    let decodedTokens = [];\n    if (rawTokens.length) {\n      rawTokens.forEach(tokenData => {\n        if (tokenData.token) {\n          let decodedToken = new this.tokenParser(this.base64ToUint8array(tokenData.token).buffer);\n          if (decodedToken && decodedToken[this.unsignedTokenDataName]) decodedTokens.push(decodedToken[this.unsignedTokenDataName]);\n        } else {\n          console.log('empty token data received');\n        }\n      })\n    }\n    return decodedTokens;\n  }\n\n  attachPostMessageListener(listener) {\n    if (window.addEventListener) {\n      window.addEventListener(\"message\", listener, false);\n    } else {\n      // IE8\n      window.attachEvent(\"onmessage\", listener);\n    }\n  }\n  detachPostMessageListener(listener) {\n    if (window.addEventListener) {\n      window.removeEventListener(\"message\", listener, false);\n    } else {\n      // IE8\n      window.detachEvent(\"onmessage\", listener);\n    }\n  }\n}","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER\n} from \"asn1js\";\nimport { getParametersValue, clearProps, bufferToHexCodes } from \"pvutils\";\nimport PublicKeyInfo from \"./PublicKeyInfo.js\";\nimport BigInt from \"big-integer\";\n\nexport class DevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String] source is CER encoded\n   */\n  constructor(source = {}) {\n    if (typeof (source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      this.devconId = getParametersValue(\n        source,\n        \"devconId\"\n      );\n      this.ticketId = getParametersValue(\n        source,\n        \"ticketId\"\n      );\n      this.ticketClass = getParametersValue(\n        source,\n        \"ticketClass\"\n      );\n    }\n  }\n\n  static schema(parameters = {}) {\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"ticket\",\n      value: [\n        new Integer({\n          name: names.devconId || \"devconId\",\n        }),\n        new Integer({\n          name: names.ticketId || \"ticketId\",\n        }),\n        new Integer({\n          name: names.ticketClass || \"ticketClass\",\n        }),\n      ],\n    });\n  }\n\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"devconId\",\n      \"ticketId\",\n      \"ticketClass\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, DevconTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\"Object's schema was not verified against input data for DevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    if (\"devconId\" in asn1.result) {\n      const devconId = asn1.result[\"devconId\"].valueBlock._valueHex;\n      this.devconId = new BigInt(\"0x\" + bufferToHexCodes(devconId)).value;\n    }\n\n    if (\"ticketId\" in asn1.result) {\n      const ticketId = asn1.result[\"ticketId\"].valueBlock._valueHex\n      this.ticketId = new BigInt(\"0x\" + bufferToHexCodes(ticketId)).value;\n    }\n\n    if (\"ticketClass\" in asn1.result) {\n      const ticketClass = asn1.result[\"ticketClass\"].valueBlock._valueHex;\n      this.ticketClass = new BigInt(\"0x\" + bufferToHexCodes(ticketClass)).value;\n    }\n\n    //endregion\n  }\n}\n\nexport class SignedDevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is DER encoded\n   */\n  constructor(source = {}) {\n    if (typeof (source) == \"string\") {\n\n      const ticketEncoded = (source.startsWith(\"https://\")) ?\n        (new URL(source)).searchParams.get('ticket') : source;\n\n      let base64str = ticketEncoded\n        .split('_').join('+')\n        .split('-').join('/')\n        .split('.').join('=');\n\n      // source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      if (typeof Buffer !== 'undefined') {\n        source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      } else {\n        source = Uint8Array.from(atob(base64str), c => c.charCodeAt(0)).buffer;\n      }\n\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source);\n      this.fromSchema(asn1.result);\n    } else {\n      this.ticket = new DevconTicket(source.ticket);\n\n      this.commitment = getParametersValue(\n        source,\n        \"commitment\"\n      );\n\n      // TODO: issue #75\n      // this.signatureAlgorithm = new AlgorithmIdentifier(source.signatureAlgorithm);\n\n      this.publicKeyInfo = new PublicKeyInfo(source.publicKeyInfo)\n\n      this.signatureValue = getParametersValue(\n        source,\n        \"signatureValue\"\n      );\n    }\n  }\n\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * CertificateList  ::=  SEQUENCE  {\n   *    tbsCertList          TBSCertList,\n   *    signatureAlgorithm   AlgorithmIdentifier,\n   *    signatureValue       BIT STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} [blockName]\n     * @property {string} [signatureAlgorithm]\n     * @property {string} [signatureValue]\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"SignedDevconTicket\",\n      value: [\n        DevconTicket.schema(parameters),\n        new OctetString({\n          name: \"commitment\",\n        }),\n        /* PublicKeyInfo is specified in schema here but not appearing in the constructed data object.\n         * This is because the underlying AlgorithmIdentifier isn't fully implemented and also\n         * that this data is not important for the 1st delivery deadline, won't be read by client anyway.\n         * TODO: add support for PublicKeyInfo https://github.com/TokenScript/attestation/issues/75\n         */\n        new Sequence({\n          name: \"publicKeyInfo\",\n          optional: true,\n          value: [\n            PublicKeyInfo.schema(\n              names.publicKeyInfo || {\n                names: {\n                  blockName: \"publicKeyInfo\",\n                },\n              }\n            )\n          ]\n        }),\n\n        new BitString({\n          name: \"signatureValue\",\n        }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"ticket\",\n      \"commitment\",\n      // TODO: #75\n      \"publicKeyInfo\",\n      \"signatureValue\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, SignedDevconTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\"Object's schema was not verified against input data for SignedDevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    this.ticket = new DevconTicket(asn1.result.ticket.valueBeforeDecode)\n\n    if (\"commitment\" in asn1.result)\n      this.commitment = asn1.result[\"commitment\"].valueBlock.valueHex;\n\n    // TODO: issue #75\n    // this.signatureAlgorithm = new AlgorithmIdentifier(asn1.result.signatureAlgorithm);\n    this.publicKeyInfo = new PublicKeyInfo({\n      schema: asn1.result.publicKeyInfo,\n    });\n\n    const signatureValue = asn1.result.signatureValue;\n    this.signatureValue = signatureValue.valueBlock.valueHex;    //endregion\n  }\n}","import React from 'react';\nimport Typography from '@material-ui/core/Typography';\nimport './Card.css';\n\nfunction MediaCard({ tokenInstance }) {\n  return (\n    <div className=\"ticketContainer\">\n      <div className=\"ticketDetails\">\n        <Typography className=\"ticketClass\" gutterBottom variant=\"h5\" component=\"h2\">\n          {tokenInstance.ticketClass.toString()}\n        </Typography>\n        <Typography className=\"ticketId\" variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          {tokenInstance.ticketId.toString()}\n        </Typography>\n        <Typography className=\"devconId\" variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          Devcon ID: {tokenInstance.devconId.toString()}\n        </Typography>\n      </div>\n      <img className=\"ticketImg\" src=\"ticket_example_image.svg\"></img>\n    </div>\n  );\n}\n\nexport default MediaCard;\n","import React, { useState, useEffect } from 'react';\n// import { Negotiator } from 'token-negotiator';\nimport { Negotiator } from './temp/negotiator';\nimport Card from './Card';\nimport './App.css';\n\n// A minimal example to read tokens and render them to a view.\n\nfunction App() {\n  // local State: tokens[], setTokens: Method to update the state of tokens.\n  let [tokens, setTokens] = useState([]);\n  // create instance of Negotiator.\n  const filter = {};\n  const options = {\n    attestationOrigin: \"https://stage.attestation.id\",\n    tokenOrigin: \"https://devcontickets.herokuapp.com/outlet/\"\n  };\n  const negotiator = new Negotiator(filter, options);\n  // react effect\n  useEffect(() => {\n    // on success assign tokens to react state\n    negotiator.getTokenInstances(res => {\n      if(res.success) setTokens(res.tokens);\n    });\n  }, []);\n  return (\n    <main className=\"pageStyles\">\n      <a href=\"/\"><img className=\"logo\" src=\"./devcon.svg\"></img></a>\n      <div className=\"flexCenter\">\n        <p>[DEMO Ticket Issuer Website]</p>\n      </div>\n      <div className=\"flexCenter\">\n        <img className=\"devcon_bogota\" src=\"./devcon_bogota.svg\"></img>\n      </div>\n      <div className=\"flexCenter\">\n        <p>A Devcon ticket provides access to the event and special offers between the dates X-XX for hotel bookings, travel, restaurants and more.</p>\n      </div>\n      <div className=\"flexCenter\">\n        <p>Your tickets:</p>\n      </div>\n      <div className=\"flexCenter\">\n        <div className=\"tokensWrapper\">\n          {\n            tokens && tokens.length > 0 && tokens.map((tokenInstance, index) => {\n              return <Card key={index} tokenInstance={tokenInstance} />\n            })\n          }\n          {\n            !tokens.length && <div>\n              <b>- no ticket found -</b>\n              <p>Click <a target=\"_blank\" href=\"https://devcontickets.herokuapp.com/outlet/?ticket=MIGbMA0CAQYCBWE3ap3-AgEABEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNHADBEAiBwLK_95NPZo0W01HDBfyZisZ2KaNrzoWuxRV-nhjGLMAIgaOP4eVVINH5xM8Cv9OVDdyOG3BxUqyPVQOuDU9PaC9o=&secret=45845870684\">here</a> to generate a ticket (for demo purposes only).</p> \n              <p>Click <a target=\"_blank\" href=\"https://devcontickets.herokuapp.com/outlet/?ticket=MIGYMAoCAQYCAgFNAgECBEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNHADBEAiB4thME54fWjTs1eJ5XseTPk7sqOUa9JzVsDMURBwTlJwIgChH-eU6seNnC8hVDgBvLvUJPpGWviWsQ2WwWrcC7Meg=&secret=45845870684\">here</a> to generate a ticket (for demo purposes only).</p> \n              <p>Click <a target=\"_blank\" href=\"https://devcontickets.herokuapp.com/outlet/?ticket=MIGZMAoCAQYCAgDeAgEBBEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNIADBFAiEAy0hGTGFw_KWyk0EbDFI7y4x8LaplJ6PEPFDb-AQ82GUCIEKP4650eRZyvbgNbTcnjRLaRthc4oIFEn7FVS2nNJ6o&secret=45845870684\">here</a> to generate a ticket (for demo purposes only).</p> \n              <p>Click <a target=\"_blank\" href=\"https://devcontickets.herokuapp.com/outlet/?ticket=MIGXMAkCAQYCAW8CAQAEQQQollXEwRduRJlkFac1RNf_mJ67wZSp_RvH9rS0E8XpBiyQAFowkFiEM5eyZC3dyyT9N8xnbB2Z9GQrt48I4jaSA0cAMEQCIFavePjptmgxBsVuHp7bZSDxK0ovB8d9URp2VjiGos56AiA9apKTL6Kk74Jgf2H7Mb4EZqlsdwJLXSN23sC6aoRyKg==&secret=45845870684\">here</a> to generate a ticket (for demo purposes only).</p> \n            </div>\n          }\n        </div>\n      </div>\n    </main>\n  );\n}\n\nexport default App;\n\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}